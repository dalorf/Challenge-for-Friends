<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="DALORF - Challenge for Friends. Test how well you know each other with personalized quiz questions in this fun multiplayer game.">
  <meta name="keywords" content="friends quiz, multiplayer game, friendship test, question game, social game">
  <meta name="author" content="DALORF Team">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:title" content="DALORF - Challenge for Friends">
  <meta property="og:description" content="Test how well you know each other with personalized quiz questions in this fun multiplayer game.">
  <meta property="og:image" content="https://via.placeholder.com/1200x630/ff80a8/ffffff?text=DALORF">
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:title" content="DALORF - Challenge for Friends">
  <meta property="twitter:description" content="Test how well you know each other with personalized quiz questions in this fun multiplayer game.">
  
  <title>DALORF - Challenge for Friends</title>
  
  <!-- Preconnect to external domains -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://www.gstatic.com">
  
  <!-- Font optimization -->
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <!-- Favicon -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü™®</text></svg>">
  
  <style>
    /* CSS Custom Properties */
    :root {
      --font-main: 'Montserrat', system-ui, -apple-system, sans-serif;
      --timing-fast: 0.2s;
      --timing-medium: 0.3s;
      --timing-slow: 0.4s;
      --timing-spring: cubic-bezier(0.68, -0.55, 0.265, 1.55);
      --timing-smooth: cubic-bezier(0.4, 0, 0.2, 1);
      --shadow-light: 0 2px 8px rgba(0, 0, 0, 0.08);
      --shadow-medium: 0 8px 24px rgba(0, 0, 0, 0.12);
      --shadow-heavy: 0 16px 48px rgba(0, 0, 0, 0.16);
      --shadow-glow: 0 0 20px rgba(255, 128, 168, 0.3);
      --border-radius: 12px;
      --border-radius-large: 16px;
      --border-radius-xl: 24px;
      --min-touch-target: 44px;
      --glass-bg: rgba(255, 255, 255, 0.05);
      --glass-border: rgba(255, 255, 255, 0.1);
    }

    /* Base Styles */
    * {
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-main);
      margin: 0;
      padding: 0;
      text-align: center;
      overflow-x: hidden;
      transition: background var(--timing-slow), color var(--timing-slow);
      line-height: 1.6;
      min-height: 100vh;
    }

    /* Enhanced focus management */
    *:focus-visible {
      outline: 3px solid;
      outline-offset: 2px;
      border-radius: 4px;
    }

    /* Theme Styles */
    .light-theme {
      --bg-primary: linear-gradient(135deg, #ffd6e1 0%, #ffe8f0 25%, #c9f6f9 75%, #b8e9f5 100%);
      --text-primary: #1a1a1a;
      --text-secondary: #666;
      --bg-card: rgba(255, 255, 255, 0.95);
      --bg-input: #f8f9fa;
      --border-input: #e1e4e8;
      --color-accent: #ff80a8;
      --color-accent-hover: #ff5a91;
      --color-accent-light: #ffe0ec;
      --bg-modal: rgba(255, 255, 255, 0.98);
      --shadow-color: rgba(0, 0, 0, 0.1);
      --bg-success: #e8f5e8;
      --text-success: #2e7d32;
      --border-success: #c8e6c9;
      --bg-error: #ffebee;
      --text-error: #c62828;
      --border-error: #ffcdd2;
      --bg-notification: #e3f2fd;
      --text-notification: #1565c0;
      --border-notification: #bbdefb;
      --overlay-bg: rgba(0, 0, 0, 0.4);
    }

    .dark-theme {
      --bg-primary: linear-gradient(135deg, #2d1b00 0%, #1a1a1a 50%, #000000 100%);
      --text-primary: #ffffff;
      --text-secondary: #b0b0b0;
      --bg-card: rgba(40, 40, 40, 0.95);
      --bg-input: #2a2a2a;
      --border-input: #404040;
      --color-accent: #ffd26b;
      --color-accent-hover: #ffbd3d;
      --color-accent-light: #3d2f00;
      --bg-modal: rgba(34, 34, 34, 0.98);
      --shadow-color: rgba(0, 0, 0, 0.5);
      --bg-success: #1b3d1b;
      --text-success: #66bb6a;
      --border-success: #2e5d2e;
      --bg-error: #3d1b1b;
      --text-error: #ef5350;
      --border-error: #5d2e2e;
      --bg-notification: #1a2332;
      --text-notification: #64b5f6;
      --border-notification: #1e3a5f;
      --overlay-bg: rgba(0, 0, 0, 0.7);
    }

    .light-theme {
      background: var(--bg-primary);
      color: var(--text-primary);
      position: relative;
      min-height: 100vh;
    }

    .light-theme::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at 20% 80%, rgba(255, 128, 168, 0.1) 0%, transparent 50%),
                  radial-gradient(circle at 80% 20%, rgba(201, 246, 249, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    .dark-theme {
      background: var(--bg-primary);
      color: var(--text-primary);
      position: relative;
      min-height: 100vh;
    }

    .dark-theme::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(circle at 20% 80%, rgba(255, 210, 107, 0.08) 0%, transparent 50%),
                  radial-gradient(circle at 80% 20%, rgba(116, 81, 0, 0.1) 0%, transparent 50%);
      pointer-events: none;
      z-index: 0;
    }

    /* Typography */
    h1 {
      font-size: clamp(2.2rem, 5vw, 3rem);
      font-weight: 800;
      color: var(--text-primary);
      margin: 0;
      letter-spacing: -0.5px;
      line-height: 1.1;
      background: linear-gradient(135deg, var(--color-accent), var(--color-accent-hover));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      position: relative;
      display: inline-block;
    }

    h1::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, transparent, var(--color-accent), transparent);
      border-radius: 2px;
      opacity: 0.5;
    }

    h3 {
      font-size: clamp(1.2rem, 3vw, 1.5rem);
      font-weight: 700;
      color: var(--text-primary);
      margin: 0 0 24px 0;
      letter-spacing: -0.3px;
      position: relative;
      padding-bottom: 12px;
    }

    h3::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 60px;
      height: 3px;
      background: linear-gradient(90deg, var(--color-accent), transparent);
      border-radius: 2px;
    }

    /* Form Elements */
    button {
      font-family: var(--font-main);
      font-size: 1.05rem;
      border-radius: var(--border-radius);
      background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-hover) 100%);
      color: #ffffff;
      font-weight: 600;
      border: none;
      padding: 14px 28px;
      margin: 8px 6px;
      cursor: pointer;
      transition: all var(--timing-medium) var(--timing-smooth);
      letter-spacing: 0.3px;
      min-height: var(--min-touch-target);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    button:hover::before {
      left: 100%;
    }

    button:hover:not(:disabled) {
      background: linear-gradient(135deg, var(--color-accent-hover) 0%, var(--color-accent) 100%);
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2), var(--shadow-glow);
    }

    button:active:not(:disabled) {
      transform: translateY(0) scale(0.98);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    button:disabled {
      background: linear-gradient(135deg, #cccccc 0%, #aaaaaa 100%);
      color: #888888;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
      opacity: 0.6;
    }

    input, select, textarea {
      font-family: var(--font-main);
      font-size: 1.05rem;
      border-radius: var(--border-radius);
      border: 2px solid var(--border-input);
      background: var(--bg-input);
      color: var(--text-primary);
      outline: none;
      transition: all var(--timing-medium) var(--timing-smooth);
      min-height: var(--min-touch-target);
      padding: 12px 16px;
      width: 100%;
      max-width: 400px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
      position: relative;
    }

    input::placeholder,
    select::placeholder,
    textarea::placeholder {
      color: var(--text-secondary);
      opacity: 0.6;
    }

    input:hover, select:hover, textarea:hover {
      border-color: color-mix(in srgb, var(--color-accent) 50%, var(--border-input));
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
    }

    input:focus, select:focus, textarea:focus {
      border-color: var(--color-accent);
      background: var(--bg-card);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), 
                  0 0 0 4px color-mix(in srgb, var(--color-accent) 15%, transparent);
      transform: translateY(-1px);
    }

    /* Buttons */
    button {
      font-family: var(--font-main);
      font-size: 1.1rem;
      border-radius: var(--border-radius);
      background: var(--color-accent);
      color: #ffffff;
      font-weight: 600;
      border: none;
      padding: 12px 24px;
      margin: 8px 6px;
      cursor: pointer;
      transition: all var(--timing-medium);
      letter-spacing: 0.4px;
      min-height: var(--min-touch-target);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    button:hover:not(:disabled) {
      background: var(--color-accent-hover);
      transform: translateY(-2px);
      box-shadow: var(--shadow-medium);
    }

    button:active:not(:disabled) {
      transform: translateY(0);
    }

    button:disabled {
      background: #cccccc;
      color: #888888;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    /* Cards and Containers */
    .question-block {
      background: var(--bg-card);
      color: var(--text-primary);
      box-shadow: var(--shadow-medium);
      border-radius: var(--border-radius-large);
      padding: 24px;
      margin: 20px auto;
      max-width: 500px;
      text-align: left;
      position: relative;
      transition: all var(--timing-medium) var(--timing-smooth);
      border: 1px solid color-mix(in srgb, var(--color-accent) 10%, transparent);
      backdrop-filter: blur(10px);
    }

    .question-block::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--color-accent), var(--color-accent-hover));
      border-radius: var(--border-radius-large) var(--border-radius-large) 0 0;
      opacity: 0;
      transition: opacity var(--timing-medium);
    }

    .question-block:hover::before {
      opacity: 1;
    }

    .question-block:hover {
      transform: translateY(-4px);
      box-shadow: var(--shadow-heavy), 0 0 0 1px color-mix(in srgb, var(--color-accent) 20%, transparent);
    }

    .main-question-input {
      background: #fff6c1 !important;
      border: 2px solid #ffb700 !important;
      font-weight: 600;
      margin-bottom: 12px;
    }

    .dark-theme .main-question-input {
      background: #4c3700 !important;
      border: 2px solid var(--color-accent) !important;
    }

    .option-input {
      margin-bottom: 8px;
      width: 100% !important;
      max-width: 100% !important;
    }

    /* Layout Components */
    .section {
      animation: sectionFadeIn 0.8s var(--timing-smooth);
      padding: 20px;
      max-width: 800px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }

    @keyframes sectionFadeIn {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .container {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      position: relative;
      z-index: 1;
    }

    /* Theme Switch */
    .theme-switch {
      position: fixed;
      top: 20px;
      right: 20px;
      background: var(--bg-card);
      color: var(--color-accent);
      font-size: 1.5rem;
      border-radius: 50%;
      border: 2px solid color-mix(in srgb, var(--color-accent) 20%, transparent);
      padding: 12px;
      cursor: pointer;
      transition: all var(--timing-medium) var(--timing-smooth);
      z-index: 1000;
      min-height: var(--min-touch-target);
      min-width: var(--min-touch-target);
      box-shadow: var(--shadow-medium);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .theme-switch:hover {
      background: var(--color-accent);
      color: #ffffff;
      transform: scale(1.15) rotate(20deg);
      box-shadow: var(--shadow-heavy), var(--shadow-glow);
      border-color: var(--color-accent);
    }

    .theme-switch:active {
      transform: scale(1.05) rotate(20deg);
    }

    /* Utility Classes */
    .hidden { display: none !important; }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    /* Messages and Notifications */
    .error-message {
      color: var(--text-error);
      background: var(--bg-error);
      border: 2px solid var(--border-error);
      padding: 14px 20px;
      border-radius: var(--border-radius-large);
      margin: 12px 0;
      font-size: 0.95rem;
      font-weight: 600;
      box-shadow: var(--shadow-light);
      animation: messageSlideIn 0.4s var(--timing-smooth);
      position: relative;
      overflow: hidden;
    }

    .error-message::before {
      content: '‚ö†Ô∏è';
      margin-right: 8px;
      font-size: 1.1rem;
    }

    .success-message {
      color: var(--text-success);
      background: var(--bg-success);
      border: 2px solid var(--border-success);
      padding: 14px 20px;
      border-radius: var(--border-radius-large);
      margin: 12px 0;
      font-size: 0.95rem;
      font-weight: 600;
      box-shadow: var(--shadow-light);
      animation: messageSlideIn 0.4s var(--timing-smooth);
      position: relative;
      overflow: hidden;
    }

    .success-message::before {
      content: '‚úÖ';
      margin-right: 8px;
      font-size: 1.1rem;
    }

    @keyframes messageSlideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .notification {
      background: var(--bg-notification);
      color: var(--text-notification);
      border: 2px solid var(--border-notification);
      padding: 18px 24px;
      border-radius: var(--border-radius-large);
      margin: 10px auto;
      max-width: 500px;
      animation: notificationSlideIn 0.5s var(--timing-spring);
      box-shadow: var(--shadow-heavy);
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
      font-weight: 500;
    }

    .notification::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(180deg, var(--color-accent), var(--color-accent-hover));
    }

    .notification::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
      animation: notificationShimmer 2s infinite;
    }

    @keyframes notificationSlideIn {
      from { 
        transform: translateX(-120%) scale(0.8);
        opacity: 0;
      }
      to { 
        transform: translateX(0) scale(1);
        opacity: 1;
      }
    }

    @keyframes notificationShimmer {
      to {
        left: 100%;
      }
    }

    .room-info {
      background: linear-gradient(135deg, 
        color-mix(in srgb, var(--color-accent) 15%, transparent),
        color-mix(in srgb, var(--color-accent) 5%, transparent));
      color: var(--text-primary);
      border: 2px solid color-mix(in srgb, var(--color-accent) 30%, transparent);
      padding: 20px 28px;
      border-radius: var(--border-radius-large);
      margin: 16px auto;
      max-width: 600px;
      font-weight: 600;
      box-shadow: var(--shadow-medium);
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(10px);
    }

    .room-info::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--color-accent), var(--color-accent-hover));
    }

    .room-info::after {
      content: '';
      position: absolute;
      top: -50%;
      right: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, transparent 70%);
      animation: roomInfoGlow 3s infinite;
      pointer-events: none;
    }

    @keyframes roomInfoGlow {
      0%, 100% {
        transform: translate(-25%, -25%);
        opacity: 0.5;
      }
      50% {
        transform: translate(0%, 0%);
        opacity: 0.8;
      }
    }

    .loading-indicator {
      color: var(--color-accent);
      font-size: 1.1rem;
      margin: 20px 0;
      animation: pulse-loading 1.2s infinite;
    }

    .timer {
      color: var(--color-accent);
      font-weight: 700;
    }

    .timer.low-time {
      animation: pulse 1s infinite;
      color: #ff5722;
    }

    /* Modal Styles */
.modal {
      display: none;
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: var(--overlay-bg);
      backdrop-filter: blur(12px);
      animation: modalFadeIn 0.3s var(--timing-smooth);
    }

    @keyframes modalFadeIn {
      from {
        opacity: 0;
        backdrop-filter: blur(0px);
      }
      to {
        opacity: 1;
        backdrop-filter: blur(12px);
      }
    }

    .modal-content {
      background: var(--bg-modal);
      color: var(--text-primary);
      margin: 5% auto;
      padding: 36px;
      border-radius: var(--border-radius-xl);
      width: 90%;
      max-width: 600px;
      max-height: 80vh;
      overflow-y: auto;
      position: relative;
      animation: modalSlideUp 0.4s var(--timing-spring);
      box-shadow: var(--shadow-heavy);
      border: 1px solid color-mix(in srgb, var(--color-accent) 15%, transparent);
      backdrop-filter: blur(20px);
    }

    @keyframes modalSlideUp {
      from {
        opacity: 0;
        transform: translateY(40px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .modal-content::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--color-accent), var(--color-accent-hover));
      border-radius: var(--border-radius-xl) var(--border-radius-xl) 0 0;
    }

    .close {
      color: var(--text-secondary);
      float: right;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      line-height: 1;
      transition: color var(--timing-fast);
    }

    .close:hover, .close:focus {
      color: var(--text-primary);
    }

    /* Share Card Canvas */
    #share-canvas {
      display: none;
      max-width: 100%;
      height: auto;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-heavy);
      margin: 16px auto;
    }

    /* Animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    @keyframes slideIn {
      from { transform: translateX(-100%); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    @keyframes pulse-loading {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    @keyframes confetti-fall {
      0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
    }

    /* Confetti */
    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      background: var(--color-accent);
      animation: confetti-fall 3s linear infinite;
      z-index: 1000;
      pointer-events: none;
    }

    .confetti:nth-child(2n) { background: #4caf50; }
    .confetti:nth-child(3n) { background: #2196f3; }
    .confetti:nth-child(4n) { background: #ff9800; }
    .confetti:nth-child(5n) { background: #9c27b0; }
    
    /* Progress Bar */
.progress-container {
  width: 100%;
  max-width: 500px;
  margin: 24px auto;
  background: var(--bg-input);
  border-radius: 20px;
  overflow: hidden;
  height: 14px;
  position: relative;
  box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
  border: 1px solid color-mix(in srgb, var(--color-accent) 10%, transparent);
}

.progress-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--color-accent), var(--color-accent-hover));
  border-radius: 20px;
  transition: width 0.6s var(--timing-smooth);
  position: relative;
  overflow: hidden;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}

.progress-bar::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background: linear-gradient(180deg, rgba(255, 255, 255, 0.3), transparent);
}

.progress-bar::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
  animation: shimmer 2s infinite;
}

@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

/* Live Indicator */
.live-indicator {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 8px 16px;
  background: var(--bg-notification);
  border: 2px solid var(--border-notification);
  border-radius: 20px;
  margin: 10px 0;
  animation: fadeIn 0.5s ease;
}

.live-dot {
  width: 8px;
  height: 8px;
  background: #4caf50;
  border-radius: 50%;
  animation: pulse-dot 1.5s infinite;
}

@keyframes pulse-dot {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.5; transform: scale(1.2); }
}

/* Sound Toggle */
.sound-toggle {
  position: fixed;
  top: 70px;
  right: 20px;
  background: var(--color-accent-light);
  color: var(--color-accent);
  font-size: 1.3rem;
  border-radius: 50%;
  border: none;
  padding: 10px;
  cursor: pointer;
  transition: all var(--timing-fast);
  z-index: 1000;
  min-height: 40px;
  min-width: 40px;
}

.sound-toggle:hover {
  background: var(--color-accent);
  color: #ffffff;
  transform: scale(1.1);
}

/* Achievement Badge */
.achievement-badge {
  display: inline-block;
  padding: 20px 32px;
  margin: 10px;
  background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-hover) 100%);
  color: white;
  border-radius: 50px;
  font-weight: 700;
  font-size: 1.2rem;
  box-shadow: var(--shadow-heavy), 0 0 40px rgba(255, 128, 168, 0.4);
  animation: badgeAppear 0.8s var(--timing-spring);
  position: relative;
  overflow: hidden;
  border: 3px solid rgba(255, 255, 255, 0.3);
}

.achievement-badge::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 70%);
  animation: badgeGlow 2s infinite;
}

@keyframes badgeGlow {
  0%, 100% {
    transform: translate(-25%, -25%);
    opacity: 0.5;
  }
  50% {
    transform: translate(0%, 0%);
    opacity: 1;
  }
}

@keyframes badgeAppear {
  0% { 
    transform: scale(0) rotate(-180deg); 
    opacity: 0; 
  }
  50% {
    transform: scale(1.2) rotate(10deg);
  }
  100% { 
    transform: scale(1) rotate(0deg); 
    opacity: 1; 
  }
}

/* Question Card Animation */
.question-block {
  animation: slideInQuestion 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
  transform-origin: center;
}

@keyframes slideInQuestion {
  0% { 
    opacity: 0; 
    transform: translateY(30px) scale(0.9);
  }
  100% { 
    opacity: 1; 
    transform: translateY(0) scale(1);
  }
}

/* Timer Challenge Mode */
.challenge-timer {
  font-size: 2.5rem;
  font-weight: 700;
  color: var(--color-accent);
  margin: 20px 0;
  animation: timerPulse 1s infinite;
}

.challenge-timer.critical {
  color: #ff5722;
  animation: timerCritical 0.5s infinite;
}

@keyframes timerPulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

@keyframes timerCritical {
  0%, 100% { transform: scale(1); color: #ff5722; }
  50% { transform: scale(1.15); color: #ff1744; }
}

/* Swipe Hint for Mobile */
.swipe-hint {
  display: none;
  padding: 8px 16px;
  background: var(--bg-notification);
  border-radius: 20px;
  margin: 10px auto;
  max-width: fit-content;
  animation: swipeHint 2s infinite;
}

@media (max-width: 768px) {
  .swipe-hint {
    display: block;
  }
}

@keyframes swipeHint {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-10px); }
  75% { transform: translateX(10px); }
}

    /* Responsive Design */
    @media (max-width: 768px) {
      h1 { font-size: 2rem; }
      h3 { font-size: 1.2rem; }
      
      .question-block {
        margin: 16px 8px;
        padding: 16px;
      }
      
      .theme-switch {
        top: 10px;
        right: 10px;
        font-size: 1.3rem;
        padding: 10px;
      }
      
      .modal-content {
        margin: 2% auto;
        width: 95%;
        padding: 20px;
      }
      
      input, select, button {
        font-size: 1rem;
      }
      
      .section {
        padding: 10px;
      }
    }

    @media (max-width: 480px) {
      .question-block {
        margin: 12px 4px;
        padding: 12px;
      }
      
      button {
        padding: 10px 16px;
        margin: 4px 2px;
      }
    }

    /* Print Styles */
    @media print {
      .theme-switch, button:not(.print-friendly) {
        display: none;
      }
      
      .modal {
        position: static;
        background: none;
      }
      
      .modal-content {
        box-shadow: none;
        border: 1px solid #ccc;
      }
    }

    /* High Contrast Mode */
    @media (prefers-contrast: high) {
      :root {
        --shadow-light: 0 2px 4px rgba(0, 0, 0, 0.5);
        --shadow-medium: 0 4px 8px rgba(0, 0, 0, 0.5);
      }
      
      button {
        border: 2px solid currentColor;
      }
    }

    /* Reduced Motion */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }

    /* Additional Components */
    .about-name-btn {
      background: transparent;
      color: var(--color-accent);
      border: none;
      font-size: 1.2rem;
      cursor: pointer;
      opacity: 0.7;
      transition: all var(--timing-fast);
      padding: 8px;
      border-radius: 50%;
      min-height: 40px;
      min-width: 40px;
    }

    .about-name-btn:hover {
      opacity: 1;
      background: var(--color-accent-light);
      transform: scale(1.1);
    }

    .automated-questions, .question-count-selector {
      background: color-mix(in srgb, var(--color-accent) 5%, transparent);
      border: 2px solid var(--color-accent);
      border-radius: var(--border-radius-large);
      padding: 20px;
      margin: 20px auto;
      max-width: 500px;
      text-align: left;
    }

    /* Auth Prompt Card */
.auth-prompt-card {
  background: var(--bg-card);
  border-radius: var(--border-radius-large);
  padding: 32px;
  margin: 20px auto;
  max-width: 500px;
  box-shadow: var(--shadow-heavy);
  text-align: center;
  border: 2px solid color-mix(in srgb, var(--color-accent) 20%, transparent);
  position: relative;
  overflow: hidden;
}

.auth-prompt-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, var(--color-accent), var(--color-accent-hover));
}

.auth-prompt-card h3 {
  margin-bottom: 12px;
  color: var(--color-accent);
}

    .intensity-selector label {
      display: block;
      margin: 10px 0;
      cursor: pointer;
      font-weight: 500;
      transition: color var(--timing-fast);
    }

    .intensity-selector label:hover {
      color: var(--color-accent);
    }

    .edit-btn, .delete-btn, .pause-edit-btn {
      font-size: 0.9rem;
      padding: 6px 12px;
      margin: 4px;
      min-height: 36px;
    }

    .edit-btn {
      background: #ffa726;
      color: #fff;
    }

    .delete-btn {
      background: #ef5350;
      color: #fff;
    }

    .pause-edit-btn {
      background: #66bb6a;
      color: #fff;
    }

    /* Focus trap for modals */
    .modal[aria-hidden="false"] {
      display: block;
    }

    /* Loading skeleton */
    .skeleton {
      background: linear-gradient(90deg, 
        color-mix(in srgb, var(--color-accent) 10%, transparent) 25%, 
        color-mix(in srgb, var(--color-accent) 20%, transparent) 50%, 
        color-mix(in srgb, var(--color-accent) 10%, transparent) 75%);
      background-size: 200% 100%;
      animation: loading 1.5s infinite;
    }

    @keyframes loading {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    /* ========================================
   AUTH & PROFILE STYLES
   ======================================== */

/* Avatar Picker */
.avatar-picker {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
  gap: 8px;
  padding: 16px;
  background: var(--bg-input);
  border-radius: var(--border-radius);
  max-height: 200px;
  overflow-y: auto;
  margin: 16px 0;
}

.avatar-option {
  font-size: 2rem;
  padding: 8px;
  cursor: pointer;
  border-radius: var(--border-radius);
  border: 2px solid transparent;
  transition: all var(--timing-fast);
  text-align: center;
}

.avatar-option:hover {
  background: color-mix(in srgb, var(--color-accent) 10%, transparent);
  transform: scale(1.1);
}

.avatar-option.selected {
  border-color: var(--color-accent);
  background: color-mix(in srgb, var(--color-accent) 20%, transparent);
}

/* Profile Card */
.profile-card {
  background: var(--bg-card);
  border-radius: var(--border-radius-xl);
  padding: 32px;
  text-align: center;
  box-shadow: var(--shadow-heavy);
  margin-bottom: 24px;
  border: 1px solid color-mix(in srgb, var(--color-accent) 15%, transparent);
  position: relative;
  overflow: hidden;
  backdrop-filter: blur(10px);
}

.profile-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 6px;
  background: linear-gradient(90deg, var(--color-accent), var(--color-accent-hover));
}

.profile-card::after {
  content: '';
  position: absolute;
  top: -50%;
  right: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(255, 255, 255, 0.03) 0%, transparent 70%);
  animation: profileGlow 4s infinite;
  pointer-events: none;
}

@keyframes profileGlow {
  0%, 100% {
    transform: translate(-25%, -25%) rotate(0deg);
  }
  50% {
    transform: translate(0%, 0%) rotate(180deg);
  }
}

.profile-avatar {
  font-size: 5rem;
  width: 120px;
  height: 120px;
  margin: 0 auto 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, 
    color-mix(in srgb, var(--color-accent) 20%, transparent),
    color-mix(in srgb, var(--color-accent) 10%, transparent));
  border-radius: 50%;
  border: 4px solid var(--color-accent);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2), 
              inset 0 2px 8px rgba(255, 255, 255, 0.1);
  transition: all var(--timing-medium) var(--timing-smooth);
  position: relative;
  z-index: 1;
}

.profile-avatar:hover {
  transform: scale(1.1) rotate(5deg);
  box-shadow: 0 12px 32px rgba(0, 0, 0, 0.3), 
              inset 0 2px 8px rgba(255, 255, 255, 0.1),
              0 0 30px color-mix(in srgb, var(--color-accent) 40%, transparent);
}

.profile-info {
  margin-top: 16px;
}

.profile-info-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px;
  margin: 8px 0;
  background: var(--bg-input);
  border-radius: var(--border-radius);
}

.profile-info-label {
  font-weight: 600;
  color: var(--text-secondary);
}

.profile-info-value {
  color: var(--text-primary);
  font-weight: 500;
}

/* Stats Display */
.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 16px;
  margin: 20px 0;
}

.stat-card {
  background: var(--bg-card);
  padding: 24px;
  border-radius: var(--border-radius-large);
  text-align: center;
  box-shadow: var(--shadow-medium);
  transition: all var(--timing-medium) var(--timing-smooth);
  border: 1px solid color-mix(in srgb, var(--color-accent) 10%, transparent);
  position: relative;
  overflow: hidden;
  backdrop-filter: blur(10px);
}

.stat-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: linear-gradient(90deg, var(--color-accent), var(--color-accent-hover));
  transform: scaleX(0);
  transition: transform var(--timing-medium) var(--timing-smooth);
}

.stat-card:hover::before {
  transform: scaleX(1);
}

.stat-card:hover {
  transform: translateY(-6px) scale(1.02);
  box-shadow: var(--shadow-heavy), 0 0 20px color-mix(in srgb, var(--color-accent) 20%, transparent);
  border-color: color-mix(in srgb, var(--color-accent) 30%, transparent);
}

.stat-value {
  font-size: 2.5rem;
  font-weight: 800;
  background: linear-gradient(135deg, var(--color-accent), var(--color-accent-hover));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 8px;
  line-height: 1;
}

.stat-label {
  font-size: 0.9rem;
  color: var(--text-secondary);
  text-transform: uppercase;
  letter-spacing: 1px;
  font-weight: 600;
}

/* Stats Tabs */
.stats-tab {
  background: transparent;
  border: 2px solid var(--border-input);
  color: var(--text-secondary);
}

.stats-tab:hover {
  border-color: var(--color-accent);
  color: var(--color-accent);
  background: color-mix(in srgb, var(--color-accent) 10%, transparent);
}

.stats-tab.active {
  background: var(--color-accent);
  border-color: var(--color-accent);
  color: #ffffff;
}

/* Leaderboard Table */
.leaderboard-table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  margin-top: 20px;
  border-radius: var(--border-radius-large);
  overflow: hidden;
  box-shadow: var(--shadow-medium);
}

.leaderboard-table th,
.leaderboard-table td {
  padding: 16px;
  text-align: left;
  border-bottom: 1px solid color-mix(in srgb, var(--border-input) 50%, transparent);
}

.leaderboard-table th {
  background: linear-gradient(135deg, 
    color-mix(in srgb, var(--color-accent) 15%, var(--bg-input)),
    var(--bg-input));
  font-weight: 700;
  color: var(--text-primary);
  position: sticky;
  top: 0;
  z-index: 10;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-size: 0.85rem;
  border-bottom: 2px solid var(--color-accent);
}

.leaderboard-table tbody tr {
  background: var(--bg-card);
  transition: all var(--timing-medium) var(--timing-smooth);
}

.leaderboard-table tbody tr:hover {
  background: color-mix(in srgb, var(--color-accent) 8%, var(--bg-card));
  transform: translateX(4px);
  box-shadow: inset 4px 0 0 var(--color-accent);
}

.leaderboard-rank {
  font-weight: 800;
  color: var(--color-accent);
  font-size: 1.2rem;
  min-width: 50px;
  display: inline-block;
}

.leaderboard-rank.top-3 {
  font-size: 1.5rem;
  background: linear-gradient(135deg, var(--color-accent), var(--color-accent-hover));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.leaderboard-me {
  background: linear-gradient(90deg,
    color-mix(in srgb, var(--color-accent) 20%, var(--bg-card)) 0%,
    color-mix(in srgb, var(--color-accent) 10%, var(--bg-card)) 100%) !important;
  border-left: 5px solid var(--color-accent);
  font-weight: 700;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.leaderboard-me:hover {
  box-shadow: inset 5px 0 0 var(--color-accent), 0 4px 12px rgba(0, 0, 0, 0.15);
}

/* Partnership Card */
.partner-card {
  background: var(--bg-card);
  border-radius: var(--border-radius-large);
  padding: 20px;
  margin-bottom: 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  box-shadow: var(--shadow-medium);
  transition: all var(--timing-medium) var(--timing-smooth);
  cursor: pointer;
  border: 1px solid color-mix(in srgb, var(--color-accent) 10%, transparent);
  position: relative;
  overflow: hidden;
  backdrop-filter: blur(10px);
}

.partner-card::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 4px;
  background: linear-gradient(180deg, var(--color-accent), var(--color-accent-hover));
  transform: scaleY(0);
  transition: transform var(--timing-medium) var(--timing-smooth);
}

.partner-card:hover::before {
  transform: scaleY(1);
}

.partner-card:hover {
  transform: translateX(8px);
  box-shadow: var(--shadow-heavy), 0 0 20px color-mix(in srgb, var(--color-accent) 15%, transparent);
  border-color: color-mix(in srgb, var(--color-accent) 25%, transparent);
}

.partner-card:active {
  transform: translateX(4px) scale(0.98);
}

.partner-badge {
  background: linear-gradient(135deg, var(--color-accent), var(--color-accent-hover));
  color: white;
  padding: 8px 16px;
  border-radius: 20px;
  font-size: 0.85rem;
  font-weight: 700;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  white-space: nowrap;
}

/* Game History Timeline */
.history-timeline {
  position: relative;
  padding-left: 24px;
  margin-top: 20px;
}

.history-timeline::before {
  content: '';
  position: absolute;
  left: 8px;
  top: 0;
  bottom: 0;
  width: 2px;
  background: var(--border-input);
}

.history-item {
  position: relative;
  padding: 16px;
  margin-bottom: 16px;
  background: var(--bg-card);
  border-radius: var(--border-radius);
  box-shadow: var(--shadow-light);
  margin-left: 16px;
}

.history-item::before {
  content: '';
  position: absolute;
  left: -24px;
  top: 20px;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--color-accent);
  border: 2px solid var(--bg-modal);
}

.history-item-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.history-opponent {
  font-weight: 600;
  color: var(--text-primary);
}

.history-date {
  font-size: 0.85rem;
  color: var(--text-secondary);
}

.history-scores {
  display: flex;
  gap: 16px;
  font-size: 0.95rem;
}

.history-score {
  display: flex;
  align-items: center;
  gap: 4px;
}

.history-score.win {
  color: var(--text-success);
  font-weight: 600;
}

.history-score.loss {
  color: var(--text-error);
}

/* Upgrade Prompt */
.upgrade-prompt {
  background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-hover) 100%);
  color: white;
  padding: 24px;
  border-radius: var(--border-radius-large);
  text-align: center;
  margin: 20px 0;
  box-shadow: var(--shadow-heavy);
  animation: pulseGlow 2s infinite;
}

@keyframes pulseGlow {
  0%, 100% { box-shadow: 0 0 20px rgba(255, 128, 168, 0.3); }
  50% { box-shadow: 0 0 40px rgba(255, 128, 168, 0.6); }
}

.upgrade-prompt h3 {
  margin: 0 0 12px 0;
  font-size: 1.5rem;
}

.upgrade-prompt p {
  margin: 0 0 16px 0;
  opacity: 0.95;
}

.upgrade-prompt button {
  background: white;
  color: var(--color-accent);
  font-weight: 700;
  padding: 12px 32px;
  font-size: 1.1rem;
}

.upgrade-prompt button:hover {
  transform: scale(1.05);
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
}

/* Empty State */
.empty-state {
  text-align: center;
  padding: 60px 20px;
  color: var(--text-secondary);
  background: var(--bg-card);
  border-radius: var(--border-radius-xl);
  margin: 20px auto;
  max-width: 500px;
  box-shadow: var(--shadow-light);
  border: 2px dashed color-mix(in srgb, var(--color-accent) 20%, transparent);
}

.empty-state-icon {
  font-size: 5rem;
  margin-bottom: 20px;
  opacity: 0.6;
  animation: emptyStateBounce 2s infinite;
  display: inline-block;
}

@keyframes emptyStateBounce {
  0%, 100% {
    transform: translateY(0);
  }
  50% {
    transform: translateY(-10px);
  }
}

.empty-state-text {
  font-size: 1.3rem;
  font-weight: 700;
  margin-bottom: 12px;
  color: var(--text-primary);
}

.empty-state-subtext {
  font-size: 1rem;
  opacity: 0.8;
  line-height: 1.6;
}

/* Badge Animations */
@keyframes badgeAppear {
  0% { 
    transform: translate(-50%, -50%) scale(0) rotate(-180deg); 
    opacity: 0; 
  }
  100% { 
    transform: translate(-50%, -50%) scale(1) rotate(0deg); 
    opacity: 1; 
  }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to { opacity: 0; }
}

/* Responsive Stats */
@media (max-width: 768px) {
  .stats-grid {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .leaderboard-table {
    font-size: 0.9rem;
  }
  
  .leaderboard-table th,
  .leaderboard-table td {
    padding: 8px 4px;
  }
  
  .partner-card {
    flex-direction: column;
    text-align: center;
    gap: 12px;
  }
  
  .history-timeline {
    padding-left: 16px;
  }
  
  .history-item {
    margin-left: 8px;
  }
}

@media (max-width: 480px) {
  .stats-grid {
    grid-template-columns: 1fr;
  }
  
  .avatar-picker {
    grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
  }
  
  .profile-avatar {
    font-size: 3rem;
    width: 80px;
    height: 80px;
  }
}

  </style>
  
  <!-- Firebase SDK -->
  <!-- BEFORE (existing code around line 645): -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
  
<!-- ADD HERE: -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

<!-- AFTER (existing): -->
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyAvaDuz1OCKYuDfieZiHynhYkur9KOPY00",
      authDomain: "birdview-025802.firebaseapp.com",
      databaseURL: "https://birdview-025802-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "birdview-025802",
      storageBucket: "birdview-025802.firebasestorage.app",
      messagingSenderId: "607338097846",
      appId: "1:607338097846:web:2ac36ce8f1261664180a17",
      measurementId: "G-Z08YPG773L"
    };
    
    try {
      firebase.initializeApp(firebaseConfig);
      window.db = firebase.database();
      window.auth = firebase.auth();
    } catch (error) {
      console.error('Firebase initialization failed:', error);
      window.db = null;
    }
  </script>
</head>

<body class="dark-theme">
  <div id="announcements" class="sr-only" aria-live="polite" aria-atomic="true"></div>
  <div id="timer-announcements" class="sr-only" aria-live="assertive" aria-atomic="true"></div>
  
  <a href="#main-content" class="sr-only" style="position: absolute; left: -10000px; top: auto; width: 1px; height: 1px; overflow: hidden;">Skip to main content</a>
  
  <div id="notifications-container" aria-live="polite"></div>

  <button class="theme-switch" id="theme-switch" aria-label="Switch between light and dark theme" title="Toggle theme">
    üåû
  </button>
  
  <main id="main-content" role="main" class="container">
    <header style="text-align: center; margin-bottom: 30px;">
      <div style="display: flex; align-items: center; justify-content: center; gap: 12px; margin-bottom: 8px; flex-wrap: wrap;">
        <h1>ü™® DALORF üêü</h1>
        <button id="about-name" class="about-name-btn" 
                title="Learn about the name DALORF" 
                aria-label="Learn about the name DALORF"
                aria-describedby="about-description">
          ‚ÑπÔ∏è
        </button>

        <button id="profile-btn" class="about-name-btn hidden" 
                title="Your Profile & Stats">
          üë§
        </button>

      </div>
      <p style="font-size: 1.3rem; margin: 0; font-weight: 600; opacity: 0.9;">Challenge for Friends</p>
      <p id="about-description" class="sr-only">Click to learn about the story behind the name DALORF</p>
    </header>

    <section id="room-info-display" class="room-info hidden" role="status" aria-live="polite">
      <div id="room-details"></div>
    </section>

    <section id="auth-section" class="section" aria-labelledby="auth-heading">
      <h3 id="auth-heading">Welcome to DALORF</h3>
      <p>Test how well you know each other! Create questions and see if your friend can answer them correctly.</p>
      
      <button onclick="showInstructions()" style="margin-bottom: 20px;" aria-describedby="instructions-help">
        üìñ How to Play
      </button>
      <p id="instructions-help" class="sr-only">Opens detailed game instructions</p>
      
      <!-- Auth Prompt (shown when not authenticated) -->
      <div id="auth-required-prompt" class="auth-prompt-card">
        <h3>üîê Sign In to Play</h3>
        <p style="margin-bottom: 20px;">Create an account or sign in to start playing DALORF with your friends!</p>
        
        <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; margin-bottom: 16px;">
          <button onclick="authManager.showAuthModal('signup')" style="flex: 1; min-width: 200px;">
            ‚ú® Create Account
          </button>
          <button onclick="authManager.showAuthModal('login')" style="flex: 1; min-width: 200px; background: #10B981;">
            üîë Sign In
          </button>
        </div>
        
        <button onclick="authManager.signInWithGoogle()" style="width: 100%; background: #4285f4; margin-bottom: 12px;">
          üîê Continue with Google
        </button>
        
        <button onclick="authManager.signInAnonymously()" style="width: 100%; background: #666;">
          üëª Continue as Guest
        </button>
        
        <p style="margin-top: 16px; font-size: 0.85rem; opacity: 0.7;">
          Guest accounts have limited features. Create a full account to save your progress!
        </p>
      </div>
      
      <!-- Room Creation/Joining (shown when authenticated) -->
      <div id="room-controls" class="hidden">
        <div style="max-width: 400px; margin: 0 auto;">
          <div style="margin-bottom: 16px;">
            <label for="playerName" class="sr-only">Your Name</label>
            <input id="playerName" 
                   placeholder="Your Name" 
                   aria-label="Enter your name"
                   aria-required="true"
                   autocomplete="name"
                   maxlength="50">
          </div>
          
          <div id="auth-error" class="error-message hidden" role="alert"></div>
          
          <div style="margin-bottom: 16px;">
            <label for="roomCode" class="sr-only">Room Code (optional)</label>
            <input id="roomCode" 
                   placeholder="Room Code (optional - leave empty for auto)" 
                   aria-label="Room code - leave empty to auto-generate"
                   autocomplete="off"
                   style="text-transform: uppercase;"
                   maxlength="10">
          </div>
          
          <div id="room-error" class="error-message hidden" role="alert"></div>
          
          <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
            <button onclick="createRoom()" aria-describedby="create-help">Create Room</button>
            <button onclick="joinRoom()" aria-describedby="join-help">Join Room</button>
          </div>
          
          <p id="create-help" class="sr-only">Creates a new game room and generates a room code</p>
          <p id="join-help" class="sr-only">Joins an existing game room using the room code</p>
        </div>
      </div>
    </section>

    <section id="join-request-section" class="section hidden" aria-labelledby="join-request-heading">
      <h3 id="join-request-heading">Waiting for Player</h3>
      
      <div class="room-info" style="margin-bottom: 24px;">
        <p style="margin: 0;">üéÆ Room Code: <strong id="waiting-room-code"></strong></p>
        <p style="margin: 8px 0 0 0; font-size: 0.9rem; opacity: 0.8;">Share this code with your friend</p>
      </div>
      
      <div style="text-align: center; margin-bottom: 24px;">
        <div class="loading-indicator" style="margin-bottom: 16px;">
          ‚è≥ Waiting for someone to join...
        </div>
        <p style="font-size: 0.85rem; color: var(--text-secondary);">
          Time waiting: <span id="wait-duration" class="timer">0:00</span>
        </p>
      </div>
      
      <div id="join-requests-container" style="max-width: 500px; margin: 0 auto;">
        <!-- Join requests will appear here -->
      </div>
      
      <div style="text-align: center; margin-top: 24px;">
        <button onclick="cancelRoom()" style="background: #ef5350;">
          ‚ùå Cancel Room
        </button>
      </div>
    </section>

    <section id="question-setup-section" class="section hidden" aria-labelledby="setup-heading">
      <h3 id="setup-heading">Game Setup</h3>
      <div class="question-count-selector">
        <h4>Number of Questions per Player:</h4>
        <label for="questionCount" class="sr-only">Choose number of questions</label>
        <select id="questionCount" aria-label="Number of questions per player">
          <option value="3">3 Questions</option>
          <option value="5" selected>5 Questions</option>
          <option value="7">7 Questions</option>
          <option value="10">10 Questions</option>
        </select>
        <br><br>
        <button onclick="startGameSetup()" id="start-setup-btn">Start Creating Questions</button>
      </div>
    </section>

    <section id="waiting-acceptance-section" class="section hidden" aria-labelledby="acceptance-heading">
      <h3 id="acceptance-heading">Join Request Sent</h3>
      
      <div class="room-info" style="margin-bottom: 24px;">
        <p style="margin: 0;">üéÆ Room Code: <strong id="acceptance-room-code"></strong></p>
      </div>
      
      <div style="text-align: center; margin-bottom: 24px;">
        <div class="loading-indicator" style="margin-bottom: 16px;">
          ‚è≥ Waiting for <strong id="acceptance-host-name"></strong> to accept your request...
        </div>
        <p style="font-size: 0.85rem; color: var(--text-secondary);">
          Time waiting: <span id="acceptance-duration" class="timer">0:00</span>
        </p>
      </div>
      
      <div id="acceptance-status" style="max-width: 500px; margin: 0 auto; text-align: center;">
        <p style="font-size: 0.95rem; opacity: 0.8;">
          The room creator will review your request shortly
        </p>
      </div>
      
      <div style="text-align: center; margin-top: 24px;">
        <button onclick="cancelJoinRequest()" style="background: #6B7280;">
          ‚Üê Back to Join
        </button>
      </div>
    </section>

    <section id="question-section" class="section hidden" aria-labelledby="questions-heading">
      <h3 id="questions-heading">Add Your Questions</h3>
      <p>Create personal questions that only someone who knows you well could answer!</p>
      
      <div class="automated-questions">
        <h4>Need Question Ideas? Try These:</h4>
        <fieldset class="intensity-selector">
          <legend class="sr-only">Choose question intensity level</legend>
          <label><input type="radio" name="intensity" value="light" checked> Light (Basic preferences)</label>
          <label><input type="radio" name="intensity" value="medium"> Medium (Personal experiences)</label>
          <label><input type="radio" name="intensity" value="deep"> Deep (Values & dreams)</label>
        </fieldset>
        <button onclick="generateAutomatedQuestions()">Get Question Suggestions</button>
        <div id="suggested-questions" aria-live="polite"></div>
      </div>
      
      <div id="questions-container" role="group" aria-label="Your questions"></div>
      <div id="question-error" class="error-message hidden" role="alert"></div>
      
      <button onclick="addQuestion()" aria-describedby="add-question-help">+ Add Question</button>
      <p id="add-question-help" class="sr-only">Adds a new question form to fill out</p>
      
      <br>
      <button onclick="submitQuestions()" id="submit-btn">Submit Questions</button>
      
      <div id="review-timer-visible" style="display:none;" role="timer" aria-live="assertive">
        ‚è≥ Reflection Time Left: <span id="timer-visible" class="timer"></span>
        <button onclick="pauseAndEdit()" id="pause-edit-btn" class="pause-edit-btn">Pause & Edit</button>
      </div>
      
      <div id="state-transition" class="notification hidden" role="status"></div>
    </section>

    <section id="waiting-section" class="section hidden" aria-labelledby="waiting-heading">
      <h3 id="waiting-heading" class="sr-only">Waiting for other player</h3>
      <div class="loading-indicator" role="status" aria-live="polite">
        ‚è≥ Waiting for the other player to submit questions...
        <span id="wait-timer" class="timer"></span>
      </div>
    </section>

    <section id="answer-section" class="section hidden" aria-labelledby="answer-heading">
      <h3 id="answer-heading">Answer Your Friend's Questions</h3>
      <div id="answer-container" role="group" aria-label="Questions to answer"></div>
      <div id="answer-error" class="error-message hidden" role="alert"></div>
      <button onclick="submitAnswers()">Submit Answers</button>
      <div id="waiting-answers" class="hidden loading-indicator" role="status">‚è≥ Loading questions...</div>
    </section>

    <section id="result-section" class="section hidden" aria-labelledby="results-heading">
      <h3 id="results-heading">Results</h3>
      <div id="result-output" role="region" aria-label="Game results"></div>
      <button onclick="location.reload()" aria-describedby="play-again-help">Play Again</button>
      <p id="play-again-help" class="sr-only">Refreshes the page to start a new game</p>
    </section>
  </main>

  <!-- Hidden canvas for generating share image -->
  <canvas id="share-canvas" width="1200" height="630"></canvas>

  <div id="about-name-modal" class="modal" role="dialog" aria-labelledby="about-modal-title" aria-hidden="true">
    <div class="modal-content">
      <button class="close" onclick="closeAboutName()" aria-label="Close about dialog">&times;</button>
      <h2 id="about-modal-title">ü™® About DALORF üêü</h2>
      
      <p><strong>DALORF</strong> is a special combination of names that represents the friendship that inspired this game:</p>
      
      <div style="background: color-mix(in srgb, var(--color-accent) 10%, transparent); padding: 20px; border-radius: var(--border-radius); margin: 20px 0; border-left: 4px solid var(--color-accent);">
        <p><strong>DA</strong> - From some names of the female friend who inspired this creation</p>
        <p><strong>LO</strong> - From some of the creator's names</p>
        <p><strong>R, F</strong> - Rock & Fish - the nicknames we often call ourselves</p>
      </div>
      
      <p>This game was born from a real friendship where we wanted to test how well we truly know each other. The name DALORF carries that personal connection and celebrates the bond between Rock and Fish.</p>
      
      <p style="font-style: italic; text-align: center; margin-top: 24px;">
        "Every great friendship deserves its own challenge!" üíñ
      </p>
    </div>
  </div>

  <div id="instructions-modal" class="modal" role="dialog" aria-labelledby="instructions-modal-title" aria-hidden="true">
    <div class="modal-content">
      <button class="close" onclick="closeInstructions()" aria-label="Close instructions dialog">&times;</button>
      <h2 id="instructions-modal-title">üéØ How to Play DALORF</h2>
      
      <section>
        <h3>üöÄ Getting Started</h3>
        <p><strong>Create a Room:</strong> Enter your name and click "Create Room" to get a unique room code.</p>
        <p><strong>Join a Room:</strong> Enter your name and the room code your friend shared, then click "Join Room".</p>
      </section>
      
      <section>
        <h3>‚ùì Question Phase</h3>
        <p><strong>Create Questions:</strong> Write personal questions about yourself with 4 multiple choice options.</p>
        <p><strong>Get Help:</strong> Use automated question suggestions with different intensity levels.</p>
        <p><strong>Examples:</strong> "What's my favorite pizza topping?", "Where did I go on my last vacation?", "What's my biggest fear?"</p>
        <p><strong>Review Time:</strong> You'll have 1 minute to review and edit your questions before they're locked in.</p>
      </section>
      
      <section>
        <h3>üéØ Answer Phase</h3>
        <p><strong>Answer Questions:</strong> Try to answer your friend's questions about them.</p>
        <p><strong>See Results:</strong> Find out how well you know each other!</p>
      </section>
      
      <section>
        <h3>üèÜ Scoring</h3>
        <ul style="text-align: left; max-width: 500px; margin: 0 auto;">
          <li><strong>Perfect (100%):</strong> üíé Perfect Harmony</li>
          <li><strong>Excellent (90-99%):</strong> üíñ Soulmate Energy</li>
          <li><strong>Great (80-89%):</strong> üòä Close Confidant</li>
          <li><strong>Good (70-79%):</strong> ü§ù Good Friends</li>
          <li><strong>Fair (60-69%):</strong> üôÇ Getting There</li>
          <li><strong>Okay (50-59%):</strong> üòê Friendly Guesswork</li>
          <li><strong>Poor (40-49%):</strong> üòÖ We Need to Talk</li>
          <li><strong>Very Poor (30-39%):</strong> üò¨ Strangers Much?</li>
          <li><strong>Terrible (20-29%):</strong> ü§î Do You Even Know Me?</li>
          <li><strong>Disaster (10-19%):</strong> üò± Who Are You?</li>
          <li><strong>Complete Miss (0-9%):</strong> üëª Ghost Friends</li>
        </ul>
      </section>
      
      <p style="margin-top: 24px;"><em>Tip: Make questions challenging but fair - the goal is to discover how well you know each other!</em></p>
    </div>
  </div>

    <!-- BEFORE (existing code around line 600): -->
        </div>
      </div>

    <!-- ADD HERE: -->
      <!-- Auth Modal -->
      <!-- Auth Modal -->
<div id="auth-modal" class="modal" role="dialog" aria-labelledby="auth-modal-title" aria-hidden="true">
  <div class="modal-content">
    <!-- Content will be dynamically generated by authManager.showAuthModal() -->
    <!-- This is just a placeholder that gets replaced -->
    <button class="close" onclick="modalManager.hide('auth-modal')" aria-label="Close authentication dialog">&times;</button>
    <div id="auth-modal-body" style="text-align: center; padding: 20px;">
      <h2>Loading...</h2>
    </div>
  </div>
</div>
        <!-- Auth UI content -->
      </div>

     <!-- Profile Modal -->
<div id="profile-modal" class="modal" role="dialog" aria-labelledby="profile-modal-title" aria-hidden="true">
  <div class="modal-content">
    <button class="close" onclick="modalManager.hide('profile-modal')" aria-label="Close profile dialog">&times;</button>
    
    <h2 id="profile-modal-title" style="text-align: center; margin-bottom: 24px;">
      üë§ Your Profile
    </h2>
    
    <div id="profile-content" style="max-width: 500px; margin: 0 auto;">
      <!-- Profile will be loaded here dynamically -->
      <div class="loading-indicator">Loading profile...</div>
    </div>
    
    <div style="text-align: center; margin-top: 24px; padding-top: 24px; border-top: 1px solid var(--border-input);">
      <button onclick="authManager.signOut()" style="background: #ef5350;">
        üö™ Sign Out
      </button>
    </div>
  </div>
</div>

   <!-- Stats/Leaderboard Modal -->
<div id="stats-modal" class="modal" role="dialog" aria-labelledby="stats-modal-title" aria-hidden="true">
  <div class="modal-content" style="max-width: 800px;">
    <button class="close" onclick="modalManager.hide('stats-modal')" aria-label="Close stats dialog">&times;</button>
    
    <h2 id="stats-modal-title" style="text-align: center; margin-bottom: 24px;">
      üìä Stats & Leaderboards
    </h2>
    
    <!-- Tab Navigation -->
    <div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 24px; flex-wrap: wrap;">
      <button id="stats-tab-personal" class="stats-tab active" onclick="showStatsTab('personal')" style="font-size: 0.95rem; padding: 8px 16px;">
        üìà My Stats
      </button>
      <button id="stats-tab-partners" class="stats-tab" onclick="showStatsTab('partners')" style="font-size: 0.95rem; padding: 8px 16px;">
        ü§ù Game Partners
      </button>
      <button id="stats-tab-global" class="stats-tab" onclick="showStatsTab('global')" style="font-size: 0.95rem; padding: 8px 16px;">
        üåç Global Leaders
      </button>
      <button id="stats-tab-history" class="stats-tab" onclick="showStatsTab('history')" style="font-size: 0.95rem; padding: 8px 16px;">
        üìú History
      </button>
    </div>
    
    <!-- Tab Content -->
    <div id="stats-tab-content" style="min-height: 300px;">
      <div class="loading-indicator">Loading stats...</div>
    </div>
  </div>
</div>

  <script>
    'use strict';

    const perfStart = performance.now();

    const APP_CONFIG = {
      REVIEW_TIME_MS: 60 * 1000,
      MAX_QUESTIONS_MULTIPLIER: 2,
      CLEANUP_DELAY_MS: 8000,
      NOTIFICATION_DURATION_MS: 4000,
      MAX_NAME_LENGTH: 50,
      MAX_ROOM_CODE_LENGTH: 10,
      DEBOUNCE_DELAY_MS: 300,
      SESSION_STORAGE_KEY: 'dalorf_game_session'
    };

    const GAME_STATES = {
      SETUP: 'setup',
      CREATING_QUESTIONS: 'creating_questions', 
      QUESTIONS_SUBMITTED: 'questions_submitted',
      REVIEW_COMPLETED: 'review_completed',
      BOTH_QUESTIONS_READY: 'both_questions_ready',
      ANSWERING: 'answering',
      COMPLETED: 'completed'
    };

    const userState = {
      currentUser: null,
      userId: null,
      username: null,
      displayName: null,
      photoURL: null,
      isAnonymous: false,
      stats: null,
      sessionId: null
    };

    // Session Manager
    const sessionManager = {
      saveSession() {
        const sessionData = {
          playerName: gameState.playerName,
          roomCode: gameState.roomCode,
          requiredQuestionCount: gameState.requiredQuestionCount,
          timestamp: Date.now()
        };
        
        try {
          sessionStorage.setItem(APP_CONFIG.SESSION_STORAGE_KEY, JSON.stringify(sessionData));
          
          // Also update URL without reloading
          if (gameState.roomCode && gameState.playerName) {
            const url = new URL(window.location);
            url.searchParams.set('room', gameState.roomCode);
            url.searchParams.set('player', gameState.playerName);
            window.history.replaceState({}, '', url);
          }
        } catch (error) {
          console.error('Failed to save session:', error);
        }
      },

      loadSession() {
        try {
          // First try URL parameters
          const urlParams = new URLSearchParams(window.location.search);
          const roomFromUrl = urlParams.get('room');
          const playerFromUrl = urlParams.get('player');
          
          if (roomFromUrl && playerFromUrl) {
            return {
              playerName: playerFromUrl,
              roomCode: roomFromUrl.toUpperCase(),
              fromUrl: true
            };
          }
          
          // Then try sessionStorage
          const saved = sessionStorage.getItem(APP_CONFIG.SESSION_STORAGE_KEY);
          if (!saved) return null;
          
          const sessionData = JSON.parse(saved);
          
          // Check if session is not too old (24 hours)
          const age = Date.now() - sessionData.timestamp;
          if (age > 24 * 60 * 60 * 1000) {
            this.clearSession();
            return null;
          }
          
          return sessionData;
        } catch (error) {
          console.error('Failed to load session:', error);
          return null;
        }
      },

      clearSession() {
        try {
          sessionStorage.removeItem(APP_CONFIG.SESSION_STORAGE_KEY);
          
          // Clear URL parameters
          const url = new URL(window.location);
          url.searchParams.delete('room');
          url.searchParams.delete('player');
          window.history.replaceState({}, '', url);
        } catch (error) {
          console.error('Failed to clear session:', error);
        }
      },

      async attemptReconnect() {
  const session = this.loadSession();
  if (!session) return false;
  
  // Check session age
  const sessionAge = Date.now() - session.timestamp;
  
  // Clear very old sessions (> 2 hours)
  if (sessionAge > 2 * 60 * 60 * 1000) {
    console.log('Session expired (>2 hours), clearing');
    this.clearSession();
    return false;
  }
  
  // NEVER auto-reconnect - ALWAYS show prompt for user choice
  // This prevents accidental reconnections on fresh page loads
  console.log('Found session, showing reconnect prompt');
  this.showReconnectPrompt(session);
  return false; // Don't auto-reconnect
},

showReconnectPrompt(session) {
  const authSection = document.getElementById('auth-section');
  const existingPrompt = document.getElementById('reconnect-prompt');
  
  if (existingPrompt) return; // Already showing prompt
  
  const sessionAge = Date.now() - session.timestamp;
  const minutesAgo = Math.floor(sessionAge / 60000);
  const timeAgoText = minutesAgo < 60 
    ? `${minutesAgo} minute${minutesAgo !== 1 ? 's' : ''} ago`
    : `${Math.floor(minutesAgo / 60)} hour${Math.floor(minutesAgo / 60) !== 1 ? 's' : ''} ago`;
  
  const prompt = document.createElement('div');
  prompt.id = 'reconnect-prompt';
  prompt.className = 'notification';
  prompt.style.cssText = 'margin: 20px auto; max-width: 600px; position: relative; padding: 20px;';
  prompt.innerHTML = `
    <button onclick="sessionManager.cancelReconnect()" 
            style="position: absolute; top: 12px; right: 12px; background: transparent; color: var(--text-primary); border: none; font-size: 1.3rem; padding: 4px 8px; cursor: pointer; line-height: 1;"
            aria-label="Dismiss"
            title="Start fresh">
      √ó
    </button>
    
    <h4 style="margin: 0 0 12px 0; font-size: 1.2rem;">üîÑ Previous Game Found</h4>
    
    <div style="background: var(--bg-card); padding: 12px; border-radius: 8px; margin: 12px 0;">
      <p style="margin: 0 0 8px 0;">
        <strong>Room Code:</strong> <code style="background: var(--color-accent-light); padding: 2px 8px; border-radius: 4px; font-size: 1.1rem;">${session.roomCode}</code>
      </p>
      <p style="margin: 0 0 8px 0;">
        <strong>Your Name:</strong> ${session.playerName}
      </p>
      <p style="margin: 0 0 8px 0;">
        <strong>Questions:</strong> ${session.requiredQuestionCount || 5} per player
      </p>
      <p style="margin: 0; color: var(--text-secondary); font-size: 0.9rem;">
        <strong>Last active:</strong> ${timeAgoText}
        ${sessionAge > 30 * 60 * 1000 ? ' <span style="color: var(--color-accent);">‚ö†Ô∏è Session may have expired</span>' : ''}
      </p>
    </div>
    
    <p style="margin: 12px 0; font-size: 0.95rem;">
      Would you like to continue where you left off?
    </p>
    
    <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
      <button onclick="sessionManager.performReconnect(${JSON.stringify(session).replace(/"/g, '&quot;')})" 
              style="flex: 1; min-width: 180px; background: #10B981; font-size: 1.05rem; padding: 12px 20px;">
        ‚Ü©Ô∏è Yes, Reconnect
      </button>
      <button onclick="sessionManager.cancelReconnect()" 
              style="flex: 1; min-width: 180px; background: #6B7280; font-size: 1.05rem; padding: 12px 20px;">
        ‚ú® No, Start Fresh
      </button>
    </div>
  `;
  
  // Insert at top of auth section
  authSection.insertBefore(prompt, authSection.firstChild);
  
  // Auto-scroll to prompt
  setTimeout(() => {
    prompt.scrollIntoView({ behavior: 'smooth', block: 'center' });
  }, 100);
  
  // Auto-dismiss after 60 seconds if no action taken
  setTimeout(() => {
    if (document.getElementById('reconnect-prompt')) {
      console.log('Reconnect prompt timed out, auto-cancelling');
      this.cancelReconnect();
    }
  }, 60000);
},

async performReconnect(session) {
  // Remove prompt if showing
  const prompt = document.getElementById('reconnect-prompt');
  if (prompt) prompt.remove();
  
  // Show reconnecting UI
  const authSection = document.getElementById('auth-section');
  const loadingDiv = document.createElement('div');
  loadingDiv.className = 'loading-indicator';
  loadingDiv.innerHTML = `
    <h3>üîÑ Reconnecting...</h3>
    <p>Restoring your game session</p>
    <p><strong>Room:</strong> ${session.roomCode} | <strong>Player:</strong> ${session.playerName}</p>
  `;
  authSection.insertBefore(loadingDiv, authSection.firstChild);
  
  utils.announceToScreenReader('Reconnecting to your game session');
  
  try {
    if (!window.db) {
      throw new Error('Database not available');
    }

    // Check if room still exists
    const roomSnapshot = await window.db.ref(`rooms/${session.roomCode}/settings`).once('value');
    
    if (!roomSnapshot.exists()) {
      utils.showNotification('Your game session has expired. Starting fresh!');
      this.clearSession();
      loadingDiv.remove();
      return false;
    }
    
    // Restore game state
    gameState.playerName = session.playerName;
    gameState.roomCode = session.roomCode;
    gameState.requiredQuestionCount = session.requiredQuestionCount || 5;
    
    // Set up listeners
    dbManager.listenForGameStateChanges();
    dbManager.updateRoomInfo();
    
    // Check current game state
    const stateSnapshot = await window.db.ref(`rooms/${session.roomCode}/gameState/${session.playerName}`).once('value');
    const myState = stateSnapshot.val();
    
    if (!myState) {
      // Player hasn't started yet
      const settings = roomSnapshot.val();
      if (settings.requiredQuestionCount) {
        gameState.requiredQuestionCount = settings.requiredQuestionCount;
        gameManager.enterQuestionMode();
      } else {
        gameManager.showSection('question-setup-section');
      }
    } else {
      // Resume based on state
      await this.resumeFromState(myState.state);
    }
    
    loadingDiv.remove();
    utils.showNotification('‚úÖ Successfully reconnected!');
    utils.announceToScreenReader('Successfully reconnected to game');
    return true;
    
  } catch (error) {
    console.error('Reconnection failed:', error);
    loadingDiv.remove();
    utils.showNotification('Failed to reconnect. Please start a new game.');
    this.clearSession();
    return false;
  }
},

      async resumeFromState(state) {
        switch(state) {
          case GAME_STATES.SETUP:
          case GAME_STATES.CREATING_QUESTIONS:
            gameManager.enterQuestionMode();
            utils.showNotification('üìù Resumed: Continue creating your questions');
            break;
            
          case GAME_STATES.QUESTIONS_SUBMITTED:
            // Load questions and show review state
            const questionsSnapshot = await window.db.ref(`rooms/${gameState.roomCode}/questions/${gameState.playerName}`).once('value');
            const questions = questionsSnapshot.val();
            
            if (questions) {
              gameManager.showSection('question-section');
              // Populate questions for viewing
              document.getElementById('questions-container').innerHTML = '';
              questions.forEach(q => {
                gameManager.addQuestion({
                  question: q.question,
                  options: q.options,
                  correct: q.correct
                });
              });
              
              // Disable all inputs
              document.querySelectorAll('.question-block input, .question-block select').forEach(el => {
                el.disabled = true;
              });
              
              document.getElementById('review-timer-visible').innerHTML = 
                '‚è∞ Review time ended. Waiting for other player...';
              document.getElementById('review-timer-visible').style.display = 'block';
              
              utils.showNotification('‚è≥ Resumed: Waiting for other player');
            }
            break;
            
          case GAME_STATES.REVIEW_COMPLETED:
          case GAME_STATES.BOTH_QUESTIONS_READY:
            gameManager.showSection('waiting-section');
            document.getElementById('waiting-section').innerHTML = 
              '<div class="loading-indicator">‚è≥ Waiting for both players to be ready...</div>';
            gameManager.startWaitingTimer();
            utils.showNotification('‚è≥ Resumed: Waiting for game to start');
            break;
            
          case GAME_STATES.ANSWERING:
            await gameManager.startAnswering();
            utils.showNotification('üéØ Resumed: Answer the questions');
            break;
            
          case GAME_STATES.COMPLETED:
            // Check if we have results to show
            const answersSnapshot = await window.db.ref(`rooms/${gameState.roomCode}/answers`).once('value');
            const allAnswers = answersSnapshot.val();
            
            if (allAnswers && allAnswers[gameState.playerName]) {
              const questionsSnapshot = await window.db.ref(`rooms/${gameState.roomCode}/questions`).once('value');
              const allQuestions = questionsSnapshot.val();
              
              if (allQuestions) {
                const otherPlayer = Object.keys(allQuestions).find(name => name !== gameState.playerName);
                
                if (otherPlayer && allAnswers[otherPlayer]) {
                  // Show results
                  await gameManager.loadQuestionsAndCalculateResults(
                    allAnswers[gameState.playerName],
                    otherPlayer,
                    allAnswers[otherPlayer]
                  );
                  utils.showNotification('üèÜ Resumed: View your results');
                } else {
                  gameManager.showSection('waiting-section');
                  document.getElementById('waiting-section').innerHTML = 
                    '<div class="loading-indicator">‚è≥ Waiting for other player to finish...</div>';
                }
              }
            }
            break;
        }
      },

      cancelReconnect() {
        this.clearSession();
        location.reload();
      }
    };

    const authManager = {
  googleProvider: null,
  
  async init() {
    if (!window.auth) {
      console.error('Firebase Auth not initialized');
      return;
    }

    // Initialize Google provider
    this.googleProvider = new firebase.auth.GoogleAuthProvider();
    
    // Listen for auth state changes
    window.auth.onAuthStateChanged(async (user) => {
      if (user) {
        await this.handleAuthUser(user);
      } else {
        this.handleNoUser();
      }
    });
  },

  async handleAuthUser(user) {
  userState.currentUser = user;
  userState.userId = user.uid;
  userState.isAnonymous = user.isAnonymous;
  
  // Load or create user profile
  const profileSnapshot = await window.db.ref(`users/${user.uid}/profile`).once('value');
  
  if (!profileSnapshot.exists()) {
    // New user - create profile
    await this.createUserProfile(user);
  } else {
    // Existing user - load profile
    const profile = profileSnapshot.val();
    userState.username = profile.username;
    userState.displayName = profile.displayName;
    userState.photoURL = profile.photoURL;
  }
  
  // Load user stats
  await this.loadUserStats();
  
  // Show profile button (always visible)
  const profileBtn = document.getElementById('profile-btn');
  if (profileBtn) {
    profileBtn.classList.remove('hidden');
    profileBtn.title = userState.isAnonymous ? 'Sign In / Create Account' : 'Your Profile & Stats';
  }
  
  // Update UI with user info
  this.updateAuthUI();
  
  // CRITICAL FIX: ALWAYS show room controls after successful auth
  // This ensures users can create/join rooms after signing in
  const authSection = document.getElementById('auth-section');
  const roomControls = document.getElementById('room-controls');
  
  // Wait for DOM to be fully ready
  await new Promise(resolve => setTimeout(resolve, 100));
  
  // Only show room controls if we're on the auth page (not in an active game)
  if (authSection && !authSection.classList.contains('hidden')) {
    this.showRoomControls();
    console.log('‚úÖ Room controls shown after auth');
  } else {
    console.log('‚ÑπÔ∏è Skipped showing room controls - user is in active game');
  }
  
  // Log for debugging
  console.log('User authenticated:', {
    uid: user.uid,
    displayName: userState.displayName,
    isAnonymous: userState.isAnonymous
  });
},

  handleNoUser() {
    // Reset user state
    Object.assign(userState, {
      currentUser: null,
      userId: null,
      username: null,
      displayName: null,
      photoURL: null,
      isAnonymous: false,
      stats: null
    });
    
    // Hide profile button
    document.getElementById('profile-btn').classList.add('hidden');
    
    // IMPORTANT: Hide room controls and show auth prompt
    this.hideRoomControls();
  },

  showRoomControls() {
  const authPrompt = document.getElementById('auth-required-prompt');
  const roomControls = document.getElementById('room-controls');
  
  if (!roomControls) {
    console.error('‚ùå room-controls element not found in DOM');
    return;
  }
  
  // Hide auth prompt with smooth transition
  if (authPrompt) {
    authPrompt.style.opacity = '0';
    authPrompt.style.transition = 'opacity 0.3s ease';
    setTimeout(() => {
      authPrompt.classList.add('hidden');
      authPrompt.style.display = 'none';
    }, 300);
  }
  
  // Show room controls with forced visibility
  roomControls.classList.remove('hidden');
  roomControls.style.display = 'block';
  roomControls.style.visibility = 'visible';
  roomControls.style.opacity = '1';
  roomControls.style.pointerEvents = 'auto';
  
  // Pre-fill name if available
  const playerNameInput = document.getElementById('playerName');
  if (playerNameInput && userState.displayName) {
    playerNameInput.value = userState.displayName;
  }
  
  // Clear any previous errors
  const authError = document.getElementById('auth-error');
  const roomError = document.getElementById('room-error');
  if (authError) authError.classList.add('hidden');
  if (roomError) roomError.classList.add('hidden');
  
  // Smart focus logic with better timing
  setTimeout(() => {
    // Only auto-focus if user isn't already typing somewhere
    const activeElement = document.activeElement;
    const isUserTyping = activeElement && 
                         (activeElement.tagName === 'INPUT' || 
                          activeElement.tagName === 'TEXTAREA');
    
    if (isUserTyping) {
      console.log('User already typing, skipping auto-focus');
      return;
    }
    
    // If name is pre-filled, focus on room code field
    // If name is empty, focus on name field
    if (playerNameInput) {
      if (playerNameInput.value && playerNameInput.value.trim().length > 0) {
        // Name already filled - focus on room code
        const roomCodeInput = document.getElementById('roomCode');
        if (roomCodeInput) {
          roomCodeInput.focus();
          roomCodeInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      } else {
        // Name empty - focus on name field
        playerNameInput.focus();
        playerNameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
  }, 400);
  
  console.log('‚úÖ Room controls shown and visible');
},

  hideRoomControls() {
    const authPrompt = document.getElementById('auth-required-prompt');
    const roomControls = document.getElementById('room-controls');
    
    if (authPrompt) {
      authPrompt.classList.remove('hidden');
      authPrompt.style.display = 'block';
    }
    
    if (roomControls) {
      roomControls.classList.add('hidden');
      roomControls.style.display = 'none';
      
      // Clear inputs
      const playerNameInput = document.getElementById('playerName');
      const roomCodeInput = document.getElementById('roomCode');
      if (playerNameInput) playerNameInput.value = '';
      if (roomCodeInput) roomCodeInput.value = '';
    }
    
    console.log('Room controls hidden');
  },

  handleNoUser() {
    // Reset user state
    Object.assign(userState, {
      currentUser: null,
      userId: null,
      username: null,
      displayName: null,
      photoURL: null,
      isAnonymous: false,
      stats: null
    });
    
    // Hide profile button
    const profileBtn = document.getElementById('profile-btn');
    if (profileBtn) profileBtn.classList.add('hidden');
    
    // IMPORTANT: Hide room controls and show auth prompt
    this.hideRoomControls();
  },

  async createUserProfile(user) {
    const timestamp = Date.now();
    
    // Generate username from email or random
    let username;
    if (user.email) {
      username = user.email.split('@')[0].toLowerCase().replace(/[^a-z0-9]/g, '');
    } else {
      username = `player_${Math.random().toString(36).substring(2, 8)}`;
    }
    
    // Ensure username is unique
    username = await this.ensureUniqueUsername(username);
    
    const profile = {
      username: username,
      displayName: user.displayName || username,
      email: user.email || null,
      photoURL: user.photoURL || this.getRandomAvatar(),
      createdAt: timestamp,
      isAnonymous: user.isAnonymous
    };
    
    // Initialize stats
    const stats = {
      totalGames: 0,
      totalWins: 0,
      averageScore: 0,
      bestScore: 0,
      currentStreak: 0,
      longestStreak: 0,
      lastPlayed: null
    };
    
    await Promise.all([
      window.db.ref(`users/${user.uid}/profile`).set(profile),
      window.db.ref(`users/${user.uid}/stats`).set(stats)
    ]);
    
    userState.username = username;
    userState.displayName = profile.displayName;
    userState.photoURL = profile.photoURL;
  },

  async ensureUniqueUsername(baseUsername) {
    const usersSnapshot = await window.db.ref('users').once('value');
    const users = usersSnapshot.val() || {};
    
    const existingUsernames = new Set();
    Object.values(users).forEach(user => {
      if (user.profile && user.profile.username) {
        existingUsernames.add(user.profile.username);
      }
    });
    
    let username = baseUsername;
    let counter = 1;
    
    while (existingUsernames.has(username)) {
      username = `${baseUsername}${counter}`;
      counter++;
    }
    
    return username;
  },

  getRandomAvatar() {
    const avatars = ['üòÄ', 'üòé', 'ü§ì', 'ü•≥', 'ü§†', 'üëª', 'ü§ñ', 'üëΩ', 'üê∂', 'üê±', 'ü¶ä', 'üêº', 'ü¶Å', 'üêØ', 'ü¶Ñ', 'üê∏'];
    return avatars[Math.floor(Math.random() * avatars.length)];
  },

  async loadUserStats() {
    if (!userState.userId) return;
    
    const statsSnapshot = await window.db.ref(`users/${userState.userId}/stats`).once('value');
    userState.stats = statsSnapshot.val() || {
      totalGames: 0,
      totalWins: 0,
      averageScore: 0,
      bestScore: 0,
      currentStreak: 0,
      longestStreak: 0
    };
  },

  updateAuthUI() {
    // Update any UI elements that show user info
    const authSection = document.getElementById('auth-section');
    if (!authSection.classList.contains('hidden')) {
      // Pre-fill name if available
      const playerNameInput = document.getElementById('playerName');
      if (playerNameInput && userState.displayName) {
        playerNameInput.value = userState.displayName;
      }
    }
  },

  showAuthPrompt() {
    // Add sign-in prompt to landing page
    const authSection = document.getElementById('auth-section');
    const existingPrompt = document.getElementById('auth-prompt');
    
    if (!existingPrompt && authSection && !authSection.classList.contains('hidden')) {
      const prompt = document.createElement('div');
      prompt.id = 'auth-prompt';
      prompt.style.cssText = 'margin: 20px auto; padding: 16px; background: var(--bg-card); border-radius: var(--border-radius); max-width: 400px; text-align: center;';
      prompt.innerHTML = `
        <p style="margin-bottom: 12px;">Want to save your stats and track progress?</p>
        <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
          <button onclick="authManager.showAuthModal('signup')" style="font-size: 0.95rem;">
            üìß Sign Up
          </button>
          <button onclick="authManager.signInWithGoogle()" style="font-size: 0.95rem; background: #4285f4;">
            üîê Google Sign-In
          </button>
          <button onclick="authManager.signInAnonymously()" style="font-size: 0.95rem; background: #666;">
            üëª Play as Guest
          </button>
        </div>
        <p style="margin-top: 12px; font-size: 0.85rem; opacity: 0.7;">
          Already have an account? <a href="#" onclick="authManager.showAuthModal('login'); return false;" style="color: var(--color-accent);">Sign In</a>
        </p>
      `;
      
      authSection.insertBefore(prompt, authSection.querySelector('div[style*="max-width: 400px"]'));
    }
  },

  async signInAnonymously() {
    try {
      const result = await window.auth.signInAnonymously();
      utils.showNotification('‚úÖ Playing as guest! Your progress will be saved temporarily.');
      return result.user;
    } catch (error) {
      console.error('Anonymous sign-in error:', error);
      utils.showNotification('‚ùå Failed to start guest session. Please try again.');
      throw error;
    }
  },

  async signInWithEmail(email, password) {
    try {
      const result = await window.auth.signInWithEmailAndPassword(email, password);
      utils.showNotification('‚úÖ Welcome back!');
      modalManager.hide('auth-modal');
      return result.user;
    } catch (error) {
      console.error('Email sign-in error:', error);
      let message = 'Failed to sign in. ';
      
      switch (error.code) {
        case 'auth/user-not-found':
          message += 'No account found with this email.';
          break;
        case 'auth/wrong-password':
          message += 'Incorrect password.';
          break;
        case 'auth/invalid-email':
          message += 'Invalid email address.';
          break;
        case 'auth/user-disabled':
          message += 'This account has been disabled.';
          break;
        default:
          message += error.message;
      }
      
      throw new Error(message);
    }
  },

  async signUpWithEmail(email, password, displayName) {
    try {
      const result = await window.auth.createUserWithEmailAndPassword(email, password);
      
      // Update display name
      await result.user.updateProfile({ displayName });
      
      utils.showNotification('‚úÖ Account created successfully!');
      modalManager.hide('auth-modal');
      return result.user;
    } catch (error) {
      console.error('Email sign-up error:', error);
      let message = 'Failed to create account. ';
      
      switch (error.code) {
        case 'auth/email-already-in-use':
          message += 'An account with this email already exists.';
          break;
        case 'auth/invalid-email':
          message += 'Invalid email address.';
          break;
        case 'auth/weak-password':
          message += 'Password should be at least 6 characters.';
          break;
        default:
          message += error.message;
      }
      
      throw new Error(message);
    }
  },

  async signInWithGoogle() {
    try {
      const result = await window.auth.signInWithPopup(this.googleProvider);
      utils.showNotification('‚úÖ Signed in with Google!');
      modalManager.hide('auth-modal');
      return result.user;
    } catch (error) {
      console.error('Google sign-in error:', error);
      
      if (error.code === 'auth/popup-closed-by-user') {
        utils.showNotification('‚ùå Sign-in cancelled.');
      } else if (error.code === 'auth/popup-blocked') {
        utils.showNotification('‚ùå Popup blocked. Please allow popups for this site.');
      } else {
        utils.showNotification('‚ùå Google sign-in failed. Please try again.');
      }
      
      throw error;
    }
  },

  async signOut() {
    try {
      await window.auth.signOut();
      utils.showNotification('‚úÖ Signed out successfully.');
      
      // Clear session
      sessionManager.clearSession();
      
      // Reload page to reset state
      setTimeout(() => location.reload(), 1000);
    } catch (error) {
      console.error('Sign-out error:', error);
      utils.showNotification('‚ùå Failed to sign out.');
    }
  },

  async upgradeAccount() {
    if (!userState.currentUser || !userState.currentUser.isAnonymous) {
      utils.showNotification('‚ö†Ô∏è You already have a full account!');
      return;
    }
    
    this.showAuthModal('upgrade');
  },

  async linkWithEmail(email, password) {
    try {
      const credential = firebase.auth.EmailAuthProvider.credential(email, password);
      const result = await userState.currentUser.linkWithCredential(credential);
      
      // Update profile to mark as non-anonymous
      await window.db.ref(`users/${userState.userId}/profile`).update({
        email: email,
        isAnonymous: false
      });
      
      userState.isAnonymous = false;
      
      utils.showNotification('‚úÖ Account upgraded! Your stats have been saved.');
      modalManager.hide('auth-modal');
      return result.user;
    } catch (error) {
      console.error('Account linking error:', error);
      let message = 'Failed to upgrade account. ';
      
      switch (error.code) {
        case 'auth/email-already-in-use':
          message += 'This email is already registered. Please sign in instead.';
          break;
        case 'auth/invalid-email':
          message += 'Invalid email address.';
          break;
        case 'auth/weak-password':
          message += 'Password should be at least 6 characters.';
          break;
        default:
          message += error.message;
      }
      
      throw new Error(message);
    }
  },

  async linkWithGoogle() {
    try {
      const result = await userState.currentUser.linkWithPopup(this.googleProvider);
      
      // Update profile
      await window.db.ref(`users/${userState.userId}/profile`).update({
        email: result.user.email,
        displayName: result.user.displayName,
        photoURL: result.user.photoURL,
        isAnonymous: false
      });
      
      userState.isAnonymous = false;
      
      utils.showNotification('‚úÖ Account upgraded with Google! Your stats have been saved.');
      modalManager.hide('auth-modal');
      return result.user;
    } catch (error) {
      console.error('Google linking error:', error);
      
      if (error.code === 'auth/credential-already-in-use') {
        utils.showNotification('‚ùå This Google account is already registered. Please sign in instead.');
      } else {
        utils.showNotification('‚ùå Failed to upgrade account.');
      }
      
      throw error;
    }
  },

  showAuthModal(mode = 'login') {
    const modal = document.getElementById('auth-modal');
    const modalContent = modal.querySelector('.modal-content');
    
    let html = '<button class="close" onclick="modalManager.hide(\'auth-modal\')">&times;</button>';
    
    if (mode === 'login') {
      html += `
        <h2>Sign In to DALORF</h2>
        <form id="login-form" style="max-width: 400px; margin: 20px auto;">
          <div style="margin-bottom: 16px;">
            <input type="email" id="login-email" placeholder="Email" required 
                   style="width: 100%; max-width: 100%;">
          </div>
          <div style="margin-bottom: 16px;">
            <input type="password" id="login-password" placeholder="Password" required 
                   style="width: 100%; max-width: 100%;">
          </div>
          <div id="login-error" class="error-message hidden"></div>
          <button type="submit" style="width: 100%;">Sign In</button>
          <button type="button" onclick="authManager.signInWithGoogle()" 
                  style="width: 100%; background: #4285f4; margin-top: 8px;">
            üîê Sign In with Google
          </button>
        </form>
        <p style="text-align: center; margin-top: 16px;">
          Don't have an account? 
          <a href="#" onclick="authManager.showAuthModal('signup'); return false;" 
             style="color: var(--color-accent); font-weight: 600;">Sign Up</a>
        </p>
      `;
    } else if (mode === 'signup') {
      html += `
        <h2>Create DALORF Account</h2>
        <form id="signup-form" style="max-width: 400px; margin: 20px auto;">
          <div style="margin-bottom: 16px;">
            <input type="text" id="signup-displayname" placeholder="Display Name" required 
                   style="width: 100%; max-width: 100%;">
          </div>
          <div style="margin-bottom: 16px;">
            <input type="email" id="signup-email" placeholder="Email" required 
                   style="width: 100%; max-width: 100%;">
          </div>
          <div style="margin-bottom: 16px;">
            <input type="password" id="signup-password" placeholder="Password (min 6 characters)" required 
                   style="width: 100%; max-width: 100%;">
          </div>
          <div id="signup-error" class="error-message hidden"></div>
          <button type="submit" style="width: 100%;">Create Account</button>
          <button type="button" onclick="authManager.signInWithGoogle()" 
                  style="width: 100%; background: #4285f4; margin-top: 8px;">
            üîê Sign Up with Google
          </button>
        </form>
        <p style="text-align: center; margin-top: 16px;">
          Already have an account? 
          <a href="#" onclick="authManager.showAuthModal('login'); return false;" 
             style="color: var(--color-accent); font-weight: 600;">Sign In</a>
        </p>
      `;
    } else if (mode === 'upgrade') {
      html += `
        <h2>üíé Upgrade Your Account</h2>
        <p style="text-align: center; margin-bottom: 20px;">
          Save your progress permanently and unlock full features!
        </p>
        <form id="upgrade-form" style="max-width: 400px; margin: 20px auto;">
          <div style="margin-bottom: 16px;">
            <input type="email" id="upgrade-email" placeholder="Email" required 
                   style="width: 100%; max-width: 100%;">
          </div>
          <div style="margin-bottom: 16px;">
            <input type="password" id="upgrade-password" placeholder="Password (min 6 characters)" required 
                   style="width: 100%; max-width: 100%;">
          </div>
          <div id="upgrade-error" class="error-message hidden"></div>
          <button type="submit" style="width: 100%;">Upgrade with Email</button>
          <button type="button" onclick="authManager.linkWithGoogle()" 
                  style="width: 100%; background: #4285f4; margin-top: 8px;">
            üîê Upgrade with Google
          </button>
        </form>
        <p style="text-align: center; margin-top: 16px; font-size: 0.9rem; opacity: 0.8;">
          Your current stats and game history will be preserved!
        </p>
      `;
    }
    
    modalContent.innerHTML = html;
    modalManager.show('auth-modal');
    
    // Attach form handlers
    setTimeout(() => {
      if (mode === 'login') {
        document.getElementById('login-form').onsubmit = async (e) => {
          e.preventDefault();
          const email = document.getElementById('login-email').value;
          const password = document.getElementById('login-password').value;
          const errorEl = document.getElementById('login-error');
          
          try {
            await this.signInWithEmail(email, password);
          } catch (error) {
            errorEl.textContent = error.message;
            errorEl.classList.remove('hidden');
          }
        };
      } else if (mode === 'signup') {
        document.getElementById('signup-form').onsubmit = async (e) => {
          e.preventDefault();
          const displayName = document.getElementById('signup-displayname').value;
          const email = document.getElementById('signup-email').value;
          const password = document.getElementById('signup-password').value;
          const errorEl = document.getElementById('signup-error');
          
          try {
            await this.signUpWithEmail(email, password, displayName);
          } catch (error) {
            errorEl.textContent = error.message;
            errorEl.classList.remove('hidden');
          }
        };
      } else if (mode === 'upgrade') {
        document.getElementById('upgrade-form').onsubmit = async (e) => {
          e.preventDefault();
          const email = document.getElementById('upgrade-email').value;
          const password = document.getElementById('upgrade-password').value;
          const errorEl = document.getElementById('upgrade-error');
          
          try {
            await this.linkWithEmail(email, password);
          } catch (error) {
            errorEl.textContent = error.message;
            errorEl.classList.remove('hidden');
          }
        };
      }
    }, 100);
  },

  async updateProfile(updates) {
    if (!userState.userId) return;
    
    try {
      await window.db.ref(`users/${userState.userId}/profile`).update(updates);
      
      // Update local state
      Object.assign(userState, updates);
      
      utils.showNotification('‚úÖ Profile updated!');
    } catch (error) {
      console.error('Profile update error:', error);
      utils.showNotification('‚ùå Failed to update profile.');
      throw error;
    }
  }
};

    const AUTOMATED_QUESTIONS = {
      light: [
        { q: "What's my favorite color?", opts: ["Blue", "Red", "Green", "Purple"] },
        { q: "What's my favorite food?", opts: ["Pizza", "Burger", "Pasta", "Sushi"] },
        { q: "What's my favorite season?", opts: ["Spring", "Summer", "Fall", "Winter"] },
        { q: "What's my favorite movie genre?", opts: ["Action", "Comedy", "Romance", "Horror"] },
        { q: "What's my favorite drink?", opts: ["Coffee", "Tea", "Soda", "Water"] },
        { q: "What's my favorite animal?", opts: ["Dog", "Cat", "Bird", "Fish"] },
        { q: "What's my preferred weather?", opts: ["Sunny", "Rainy", "Cloudy", "Snowy"] },
        { q: "What's my favorite day of the week?", opts: ["Monday", "Wednesday", "Friday", "Saturday"] }
      ],
      medium: [
        { q: "What's my biggest fear?", opts: ["Heights", "Spiders", "Public speaking", "Dark"] },
        { q: "Where did I go on my last vacation?", opts: ["Beach", "Mountains", "City", "Countryside"] },
        { q: "What's my dream job?", opts: ["Teacher", "Doctor", "Artist", "Engineer"] },
        { q: "What makes me happiest?", opts: ["Friends", "Family", "Achievements", "Hobbies"] },
        { q: "What's my biggest pet peeve?", opts: ["Loud chewing", "Being late", "Messy spaces", "Interrupting"] },
        { q: "What's my favorite childhood memory?", opts: ["Birthday party", "Family trip", "School event", "Holiday"] },
        { q: "What sport did I play/want to play?", opts: ["Soccer", "Basketball", "Tennis", "Swimming"] },
        { q: "What's my guilty pleasure?", opts: ["Reality TV", "Junk food", "Online shopping", "Social media"] }
      ],
      deep: [
        { q: "What's my biggest life goal?", opts: ["Career success", "Family happiness", "Personal growth", "Making a difference"] },
        { q: "What do I value most in friendship?", opts: ["Loyalty", "Honesty", "Fun", "Support"] },
        { q: "What's my biggest regret?", opts: ["Not taking risks", "Hurting someone", "Missing opportunities", "Being too cautious"] },
        { q: "What motivates me the most?", opts: ["Recognition", "Personal satisfaction", "Helping others", "Competition"] },
        { q: "What's my philosophy on life?", opts: ["Live each day fully", "Plan for the future", "Help others", "Follow your dreams"] },
        { q: "What would I change about myself?", opts: ["Be more confident", "Be more patient", "Be more organized", "Be more social"] },
        { q: "What's my definition of success?", opts: ["Financial stability", "Personal happiness", "Impact on others", "Achieving goals"] },
        { q: "What's my biggest strength?", opts: ["Empathy", "Determination", "Creativity", "Leadership"] }
      ]
    };

    const statsManager = {
  async saveGameResults(gameData) {
    if (!userState.userId) {
      console.log('No user ID - skipping stats save');
      return;
    }
    
    // Save basic stats even for anonymous users (in-memory)
    // But skip leaderboard/partnership updates for anonymous users

    const {
      myScore,
      theirScore,
      opponentUserId,
      opponentName,
      roundNumber = 1,
      questionsCount
    } = gameData;

    try {
      // Update personal stats
      await this.updatePersonalStats(myScore, theirScore);
      
      // Update partnership stats
      if (opponentUserId) {
        await this.updatePartnershipStats(opponentUserId, opponentName, myScore, theirScore);
      }
      
      // Update global leaderboard
      await this.updateGlobalLeaderboard(myScore);
      
      // Save game history
      await this.saveGameHistory(gameData);
      
      // Check for achievements
      await this.checkAchievements(myScore);
      
    } catch (error) {
      console.error('Error saving game results:', error);
    }
  },

  async updatePersonalStats(myScore, theirScore = null) {
    const userId = userState.userId;
    const statsRef = window.db.ref(`users/${userId}/stats`);
    
    const snapshot = await statsRef.once('value');
    const currentStats = snapshot.val() || {
      totalGames: 0,
      totalWins: 0,
      averageScore: 0,
      bestScore: 0,
      currentStreak: 0,
      longestStreak: 0,
      lastPlayed: null,
      totalScore: 0
    };

    const isWin = myScore >= 70; // 70% or higher is a "win"
    const newTotalGames = currentStats.totalGames + 1;
    const newTotalWins = currentStats.totalWins + (isWin ? 1 : 0);
    const newTotalScore = (currentStats.totalScore || 0) + myScore;
    const newAverageScore = Math.round(newTotalScore / newTotalGames);
    const newBestScore = Math.max(currentStats.bestScore, myScore);
    
    // Update streak
    let newCurrentStreak = isWin ? currentStats.currentStreak + 1 : 0;
    let newLongestStreak = Math.max(currentStats.longestStreak, newCurrentStreak);

    const updatedStats = {
      totalGames: newTotalGames,
      totalWins: newTotalWins,
      averageScore: newAverageScore,
      bestScore: newBestScore,
      currentStreak: newCurrentStreak,
      longestStreak: newLongestStreak,
      lastPlayed: Date.now(),
      totalScore: newTotalScore
    };

    await statsRef.update(updatedStats);
    
    // Update local state
    userState.stats = updatedStats;
  },

  async updatePartnershipStats(opponentUserId, opponentName, myScore, theirScore) {
    const userId = userState.userId;
    
    // Create partnership ID (alphabetically sorted for consistency)
    const partnershipId = [userId, opponentUserId].sort().join('_');
    
    const partnershipRef = window.db.ref(`partnerships/${partnershipId}`);
    const snapshot = await partnershipRef.once('value');
    
    const currentData = snapshot.val() || {
      players: {
        [userId]: { name: userState.displayName || userState.username },
        [opponentUserId]: { name: opponentName }
      },
      gamesPlayed: 0,
      scores: [],
      createdAt: Date.now()
    };

    // Add new game score
    const newScores = [...(currentData.scores || []), {
      timestamp: Date.now(),
      [userId]: myScore,
      [opponentUserId]: theirScore || 0,
      roundNumber: gameState.currentRound || 1
    }];

    // Keep only last 50 games
    if (newScores.length > 50) {
      newScores.shift();
    }

    // Calculate average scores
    const myScores = newScores.map(s => s[userId] || 0);
    const theirScores = newScores.map(s => s[opponentUserId] || 0);
    
    const myAvgScore = Math.round(myScores.reduce((a, b) => a + b, 0) / myScores.length);
    const theirAvgScore = Math.round(theirScores.reduce((a, b) => a + b, 0) / theirScores.length);

    const updatedData = {
      ...currentData,
      players: {
        [userId]: { 
          name: userState.displayName || userState.username,
          avgScore: myAvgScore 
        },
        [opponentUserId]: { 
          name: opponentName,
          avgScore: theirAvgScore 
        }
      },
      gamesPlayed: currentData.gamesPlayed + 1,
      scores: newScores,
      lastPlayed: Date.now()
    };

    await partnershipRef.set(updatedData);
    
    // Also update user's game partners list
    await window.db.ref(`users/${userId}/gamePartners/${opponentUserId}`).set({
      name: opponentName,
      gamesPlayed: updatedData.gamesPlayed,
      myAvgScore: myAvgScore,
      theirAvgScore: theirAvgScore,
      lastPlayed: Date.now()
    });
  },

  async updateGlobalLeaderboard(score) {
    const userId = userState.userId;
    const leaderboardRef = window.db.ref('leaderboards/global');
    
    const snapshot = await leaderboardRef.once('value');
    const leaderboard = snapshot.val() || { players: [] };
    
    // Find user in leaderboard
    let playerEntry = leaderboard.players.find(p => p.userId === userId);
    
    if (playerEntry) {
      // Update existing entry
      playerEntry.totalGames++;
      playerEntry.totalScore += score;
      playerEntry.avgScore = Math.round(playerEntry.totalScore / playerEntry.totalGames);
      playerEntry.bestScore = Math.max(playerEntry.bestScore, score);
      playerEntry.lastPlayed = Date.now();
    } else {
      // Add new entry
      playerEntry = {
        userId: userId,
        username: userState.username,
        displayName: userState.displayName,
        photoURL: userState.photoURL,
        totalGames: 1,
        totalScore: score,
        avgScore: score,
        bestScore: score,
        lastPlayed: Date.now()
      };
      leaderboard.players.push(playerEntry);
    }
    
    // Sort by average score (descending)
    leaderboard.players.sort((a, b) => b.avgScore - a.avgScore);
    
    // Keep top 100 only
    if (leaderboard.players.length > 100) {
      leaderboard.players = leaderboard.players.slice(0, 100);
    }
    
    await leaderboardRef.set(leaderboard);
  },

  async saveGameHistory(gameData) {
    const userId = userState.userId;
    const historyRef = window.db.ref(`users/${userId}/gameHistory`);
    
    const gameRecord = {
      timestamp: Date.now(),
      roomCode: gameState.roomCode,
      opponentName: gameData.opponentName,
      opponentUserId: gameData.opponentUserId || null,
      myScore: gameData.myScore,
      theirScore: gameData.theirScore,
      roundNumber: gameData.roundNumber || 1,
      questionsCount: gameData.questionsCount || 5
    };
    
    // Push to history
    await historyRef.push(gameRecord);
    
    // Clean up old history (keep last 100 games)
    const historySnapshot = await historyRef.orderByChild('timestamp').once('value');
    const history = historySnapshot.val();
    
    if (history) {
      const entries = Object.entries(history);
      if (entries.length > 100) {
        // Remove oldest entries
        const toRemove = entries
          .sort((a, b) => a[1].timestamp - b[1].timestamp)
          .slice(0, entries.length - 100);
        
        const updates = {};
        toRemove.forEach(([key]) => {
          updates[key] = null;
        });
        
        await historyRef.update(updates);
      }
    }
  },

  async checkAchievements(score) {
    const achievements = [];
    const stats = userState.stats;
    
    if (!stats) return;
    
    // First game
    if (stats.totalGames === 1) {
      achievements.push({ 
        title: 'üéÆ First Game', 
        description: 'Played your first DALORF game!' 
      });
    }
    
    // Perfect score
    if (score === 100) {
      achievements.push({ 
        title: 'üíé Perfect Score', 
        description: 'Got 100% on a game!' 
      });
    }
    
    // Win streak milestones
    if (stats.currentStreak === 3) {
      achievements.push({ 
        title: 'üî• Hot Streak', 
        description: '3 wins in a row!' 
      });
    }
    if (stats.currentStreak === 5) {
      achievements.push({ 
        title: 'üî•üî• Blazing Streak', 
        description: '5 wins in a row!' 
      });
    }
    if (stats.currentStreak === 10) {
      achievements.push({ 
        title: 'üî•üî•üî• Legendary Streak', 
        description: '10 wins in a row!' 
      });
    }
    
    // Game count milestones
    if (stats.totalGames === 10) {
      achievements.push({ 
        title: 'üéØ Dedicated Player', 
        description: 'Played 10 games!' 
      });
    }
    if (stats.totalGames === 50) {
      achievements.push({ 
        title: 'üèÜ DALORF Enthusiast', 
        description: 'Played 50 games!' 
      });
    }
    if (stats.totalGames === 100) {
      achievements.push({ 
        title: 'üëë DALORF Legend', 
        description: 'Played 100 games!' 
      });
    }
    
    // Show achievements
    if (achievements.length > 0) {
      setTimeout(() => {
        achievements.forEach((achievement, index) => {
          setTimeout(() => {
            this.showAchievement(achievement);
          }, index * 2000);
        });
      }, 2000); // Show after results are displayed
    }
  },

  showAchievement(achievement) {
    const achievementEl = document.createElement('div');
    achievementEl.className = 'achievement-badge';
    achievementEl.innerHTML = `
      <div style="font-size: 1.3rem; margin-bottom: 4px;">${achievement.title}</div>
      <div style="font-size: 0.9rem; opacity: 0.9;">${achievement.description}</div>
    `;
    achievementEl.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 3000;
      padding: 24px 32px;
      background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-hover) 100%);
      color: white;
      border-radius: 16px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      animation: badgeAppear 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      text-align: center;
    `;
    
    document.body.appendChild(achievementEl);
    
    setTimeout(() => {
      achievementEl.style.animation = 'fadeOut 0.5s ease';
      setTimeout(() => achievementEl.remove(), 500);
    }, 3000);
  },

  async getPersonalStats() {
    if (!userState.userId) return null;
    
    const statsSnapshot = await window.db.ref(`users/${userState.userId}/stats`).once('value');
    const stats = statsSnapshot.val();
    
    if (!stats) return null;
    
    // Calculate additional metrics
    const winRate = stats.totalGames > 0 
      ? Math.round((stats.totalWins / stats.totalGames) * 100) 
      : 0;
    
    return {
      ...stats,
      winRate
    };
  },

  async getGamePartners() {
    if (!userState.userId) return [];
    
    const partnersSnapshot = await window.db.ref(`users/${userState.userId}/gamePartners`).once('value');
    const partners = partnersSnapshot.val();
    
    if (!partners) return [];
    
    // Convert to array and sort by games played
    return Object.entries(partners)
      .map(([partnerId, data]) => ({
        partnerId,
        ...data
      }))
      .sort((a, b) => b.gamesPlayed - a.gamesPlayed);
  },

  async getPartnershipDetails(partnerId) {
    const userId = userState.userId;
    const partnershipId = [userId, partnerId].sort().join('_');
    
    const snapshot = await window.db.ref(`partnerships/${partnershipId}`).once('value');
    return snapshot.val();
  },

  async getGlobalLeaderboard(limit = 20) {
    const snapshot = await window.db.ref('leaderboards/global/players')
      .orderByChild('avgScore')
      .limitToLast(limit)
      .once('value');
    
    const players = snapshot.val();
    
    if (!players) return [];
    
    // Convert to array and reverse (highest score first)
    return Object.values(players).reverse();
  },

  async getMyRank() {
    if (!userState.userId) return null;
    
    const leaderboard = await this.getGlobalLeaderboard(100);
    const myRank = leaderboard.findIndex(p => p.userId === userState.userId);
    
    return myRank !== -1 ? myRank + 1 : null;
  },

  async getGameHistory(limit = 20) {
    if (!userState.userId) return [];
    
    const snapshot = await window.db.ref(`users/${userState.userId}/gameHistory`)
      .orderByChild('timestamp')
      .limitToLast(limit)
      .once('value');
    
    const history = snapshot.val();
    
    if (!history) return [];
    
    // Convert to array and reverse (newest first)
    return Object.entries(history)
      .map(([id, data]) => ({ id, ...data }))
      .reverse();
  },

  formatStats(stats) {
    if (!stats) return 'No stats available';
    
    return `
      Games: ${stats.totalGames} | 
      Wins: ${stats.totalWins} | 
      Win Rate: ${stats.winRate}% | 
      Avg Score: ${stats.averageScore}% | 
      Best: ${stats.bestScore}% | 
      Streak: ${stats.currentStreak} üî•
    `;
  },

  async getUserIdByName(playerName) {
    // Search for user by display name or username
    const usersSnapshot = await window.db.ref('users').once('value');
    const users = usersSnapshot.val();
    
    if (!users) return null;
    
    for (const [userId, userData] of Object.entries(users)) {
      if (userData.profile) {
        const profile = userData.profile;
        if (profile.displayName === playerName || profile.username === playerName) {
          return userId;
        }
      }
    }
    
    return null;
  },

  async createSession(roomCode) {
    if (!userState.userId) return null;
    
    const sessionId = `session_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`;
    
    const sessionData = {
      sessionId,
      roomCode,
      players: [userState.userId],
      createdBy: userState.userId,
      createdAt: Date.now(),
      lastActivity: Date.now(),
      currentRound: 1,
      status: 'active'
    };
    
    await window.db.ref(`sessions/${sessionId}`).set(sessionData);
    
    userState.sessionId = sessionId;
    return sessionId;
  },

  async addPlayerToSession(sessionId, playerId) {
    const sessionRef = window.db.ref(`sessions/${sessionId}`);
    const snapshot = await sessionRef.once('value');
    const session = snapshot.val();
    
    if (!session) {
      console.error('Session not found');
      return;
    }
    
    if (!session.players.includes(playerId)) {
      session.players.push(playerId);
      session.lastActivity = Date.now();
      
      await sessionRef.update({
        players: session.players,
        lastActivity: session.lastActivity
      });
    }
  },

  async saveRoundResults(sessionId, roundNumber, results) {
    const roundRef = window.db.ref(`sessions/${sessionId}/rounds/${roundNumber}`);
    
    await roundRef.set({
      ...results,
      completedAt: Date.now()
    });
    
    // Update session last activity
    await window.db.ref(`sessions/${sessionId}`).update({
      lastActivity: Date.now(),
      currentRound: roundNumber
    });
  },

  async getSessionRounds(sessionId) {
    const snapshot = await window.db.ref(`sessions/${sessionId}/rounds`).once('value');
    return snapshot.val() || {};
  },

  async incrementSessionRound(sessionId) {
    const sessionRef = window.db.ref(`sessions/${sessionId}`);
    const snapshot = await sessionRef.once('value');
    const session = snapshot.val();
    
    if (!session) return 1;
    
    const newRound = (session.currentRound || 1) + 1;
    
    await sessionRef.update({
      currentRound: newRound,
      lastActivity: Date.now()
    });
    
    return newRound;
  },

  async endSession(sessionId) {
    await window.db.ref(`sessions/${sessionId}`).update({
      status: 'completed',
      endedAt: Date.now()
    });
  },

  calculateTrendingScore(avgScore, gamesPlayed, recentActivity) {
    // Trending score formula: avgScore * (1 + log(gamesPlayed)) * activityBonus
    const activityBonus = recentActivity < 7 ? 1.2 : recentActivity < 30 ? 1.0 : 0.8;
    const gamesBonus = gamesPlayed > 0 ? Math.log10(gamesPlayed + 1) : 0;
    
    return avgScore * (1 + gamesBonus * 0.1) * activityBonus;
  }
};

    let gameState = {
      playerName: null,
      roomCode: null,
      otherPlayerName: null,
      opponentUserId: null,
      opponentName: null,
      currentRound: 1,
      requiredQuestionCount: 5,
      reviewEndTime: null,
      reviewInterval: null,
      isReviewPaused: false,
      reviewCompleted: false,
      gameStateListener: null,
      waitStartTime: null,
      myScore: null,
      myTag: null,
      otherScore: null,
      otherTag: null
    };

    const utils = {
      debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(timeout);
            func(...args);
          };
          clearTimeout(timeout);
          timeout = setTimeout(later, wait);
        };
      },

      sanitizeInput(input, maxLength = 100) {
        return input.trim().substring(0, maxLength);
      },

      generateRoomCode() {
        return Math.random().toString(36).substring(2, 8).toUpperCase();
      },

      formatTime(ms) {
        const minutes = Math.floor(ms / 60000);
        const seconds = Math.floor((ms % 60000) / 1000);
        return `${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
      },

      announceToScreenReader(message, urgent = false) {
        const announceEl = document.getElementById(urgent ? 'timer-announcements' : 'announcements');
        announceEl.textContent = message;
        setTimeout(() => announceEl.textContent = '', 1000);
      },

      showError(elementId, message) {
        const errorEl = document.getElementById(elementId);
        if (!errorEl) return;
        
        errorEl.textContent = message;
        errorEl.className = 'error-message';
        errorEl.classList.remove('hidden');
        
        setTimeout(() => {
          if (errorEl.textContent === message) {
            errorEl.classList.add('hidden');
          }
        }, 5000);
      },

      showSuccess(elementId, message) {
        const errorEl = document.getElementById(elementId);
        if (!errorEl) return;
        
        errorEl.textContent = message;
        errorEl.className = 'success-message';
        errorEl.classList.remove('hidden');
        
        setTimeout(() => {
          if (errorEl.textContent === message) {
            errorEl.classList.add('hidden');
            errorEl.className = 'error-message';
          }
        }, 3000);
      },

      showNotification(message, duration = APP_CONFIG.NOTIFICATION_DURATION_MS) {
        const container = document.getElementById('notifications-container');
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        notification.setAttribute('role', 'status');
        container.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.remove();
          }
        }, duration);
      }

      
    };

    const themeManager = {
      init() {
        const savedTheme = localStorage.getItem('dalorf-theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const theme = savedTheme || (prefersDark ? 'dark' : 'light');
        
        this.setTheme(theme);
        this.setupMediaQuery();
      },

      setTheme(theme) {
        const body = document.body;
        const themeBtn = document.getElementById('theme-switch');
        
        if (theme === 'light') {
          body.className = 'light-theme';
          themeBtn.textContent = 'üåô';
          themeBtn.setAttribute('aria-label', 'Switch to dark theme');
        } else {
          body.className = 'dark-theme';
          themeBtn.textContent = 'üåû';
          themeBtn.setAttribute('aria-label', 'Switch to light theme');
        }
        
        localStorage.setItem('dalorf-theme', theme);
      },

      toggle() {
        const isDark = document.body.classList.contains('dark-theme');
        this.setTheme(isDark ? 'light' : 'dark');
      },

      setupMediaQuery() {
        const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        mediaQuery.addEventListener('change', (e) => {
          if (!localStorage.getItem('dalorf-theme')) {
            this.setTheme(e.matches ? 'dark' : 'light');
          }
        });
      }
    };

    const modalManager = {
      show(modalId) {
        const modal = document.getElementById(modalId);
        if (!modal) return;
        
        modal.style.display = 'block';
        document.body.style.overflow = 'hidden';
        
        const firstFocusable = modal.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        if (firstFocusable) {
          firstFocusable.focus();
        }
        
        this.trapFocus(modal);
      },

      hide(modalId) {
        const modal = document.getElementById(modalId);
        if (!modal) return;
        
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
        document.body.style.overflow = 'auto';
      },

      trapFocus(modal) {
        const focusableElements = modal.querySelectorAll(
          'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );
        const firstFocusable = focusableElements[0];
        const lastFocusable = focusableElements[focusableElements.length - 1];

        modal.addEventListener('keydown', (e) => {
          if (e.key === 'Tab') {
            if (e.shiftKey) {
              if (document.activeElement === firstFocusable) {
                lastFocusable.focus();
                e.preventDefault();
              }
            } else {
              if (document.activeElement === lastFocusable) {
                firstFocusable.focus();
                e.preventDefault();
              }
            }
          }
        });
      }
    };

    const dbManager = {
      async updateGameState(newState, additionalData = {}) {
        if (!window.db) {
          console.warn('Database not available');
          return Promise.resolve();
        }

        const stateData = {
          state: newState,
          player: gameState.playerName,
          timestamp: Date.now(),
          ...additionalData
        };
        
        try {
          await window.db.ref(`rooms/${gameState.roomCode}/gameState/${gameState.playerName}`).set(stateData);
        } catch (error) {
          console.error('Failed to update game state:', error);
          throw error;
        }
      },

      listenForGameStateChanges() {
        if (!window.db) return;
        
        if (gameState.gameStateListener) {
          gameState.gameStateListener.off();
        }
        
        gameState.gameStateListener = window.db.ref(`rooms/${gameState.roomCode}/gameState`);
        gameState.gameStateListener.on('value', (snapshot) => {
          const states = snapshot.val();
          if (!states) return;
          
          const players = Object.keys(states);
          const otherPlayer = players.find(p => p !== gameState.playerName);
          
          if (otherPlayer && !gameState.otherPlayerName) {
            gameState.otherPlayerName = otherPlayer;
            this.updateRoomInfo();
            
            // Try to get opponent's userId for stats tracking
            if (!gameState.opponentUserId) {
              statsManager.getUserIdByName(otherPlayer).then(userId => {
                if (userId) {
                  gameState.opponentUserId = userId;
                  gameState.opponentName = otherPlayer;
                }
              });
            }
          }

          // Only check for transition if both players exist
          if (players.length === 2) {
            const myState = states[gameState.playerName]?.state;
            const otherState = states[otherPlayer]?.state;
            
            // Check if BOTH players have actually completed their review
            // (not just created questions, but finished the review timer or manually completed)
            const bothActuallyReady = (
              (myState === GAME_STATES.REVIEW_COMPLETED || 
               myState === GAME_STATES.BOTH_QUESTIONS_READY ||
               myState === GAME_STATES.ANSWERING) &&
              (otherState === GAME_STATES.REVIEW_COMPLETED || 
               otherState === GAME_STATES.BOTH_QUESTIONS_READY ||
               otherState === GAME_STATES.ANSWERING)
            );
            
            if (bothActuallyReady) {
              // Only transition if we haven't already
              if (myState === GAME_STATES.REVIEW_COMPLETED) {
                this.updateGameState(GAME_STATES.BOTH_QUESTIONS_READY).then(() => {
                  gameManager.transitionToAnswering();
                });
              } else if (myState === GAME_STATES.BOTH_QUESTIONS_READY) {
                if (otherState === GAME_STATES.BOTH_QUESTIONS_READY || otherState === GAME_STATES.ANSWERING) {
                  gameManager.transitionToAnswering();
                }
              }
            }
          }
        });
      },

      updateRoomInfo() {
  const roomInfo = document.getElementById('room-info-display');
  const roomDetails = document.getElementById('room-details');
  
  let content = `
    üè† Room: <strong>${gameState.roomCode}</strong> 
    <button onclick="copyRoomCode()" style="padding: 4px 12px; font-size: 0.85rem; margin: 0 8px; border-radius: 6px;">
      üìã Copy
    </button>
    | üë§ You: ${gameState.playerName}`;
  
  if (gameState.otherPlayerName) {
    content += ` | üë• Joined: ${gameState.otherPlayerName}`;
  }
  
  roomDetails.innerHTML = content;
  roomInfo.classList.remove('hidden');
}
    };

    const shareManager = {
      generateShareImage() {
        const canvas = document.getElementById('share-canvas');
        const ctx = canvas.getContext('2d');
        
        const isDark = document.body.classList.contains('dark-theme');
        
        // Background gradient
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        if (isDark) {
          gradient.addColorStop(0, '#745100');
          gradient.addColorStop(1, '#000000');
        } else {
          gradient.addColorStop(0, '#ffd6e1');
          gradient.addColorStop(1, '#c9f6f9');
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Title
        ctx.fillStyle = isDark ? '#ffffff' : '#232323';
        ctx.font = 'bold 60px Montserrat, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('ü™® DALORF üêü', canvas.width / 2, 100);
        
        ctx.font = '32px Montserrat, sans-serif';
        ctx.fillText('Challenge Results', canvas.width / 2, 160);
        
        // Card background
        ctx.fillStyle = isDark ? 'rgba(34, 34, 34, 0.9)' : 'rgba(255, 255, 255, 0.9)';
        ctx.fillRect(100, 220, canvas.width - 200, 320);
        
        // Results
        ctx.fillStyle = isDark ? '#ffd26b' : '#ff80a8';
        ctx.font = 'bold 36px Montserrat, sans-serif';
        ctx.textAlign = 'left';
        
        let yPos = 280;
        
        if (gameState.myScore !== null) {
          ctx.fillText(`${gameState.playerName}: ${gameState.myScore}%`, 150, yPos);
          ctx.font = '28px Montserrat, sans-serif';
          ctx.fillStyle = isDark ? '#ffffff' : '#232323';
          ctx.fillText(gameState.myTag, 150, yPos + 40);
          yPos += 100;
        }
        
        if (gameState.otherScore !== null) {
          ctx.fillStyle = isDark ? '#ffd26b' : '#ff80a8';
          ctx.font = 'bold 36px Montserrat, sans-serif';
          ctx.fillText(`${gameState.otherPlayerName}: ${gameState.otherScore}%`, 150, yPos);
          ctx.font = '28px Montserrat, sans-serif';
          ctx.fillStyle = isDark ? '#ffffff' : '#232323';
          ctx.fillText(gameState.otherTag, 150, yPos + 40);
        }
        
        // Footer
        ctx.fillStyle = isDark ? '#cccccc' : '#666666';
        ctx.font = '24px Montserrat, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Test how well YOU know your friends!', canvas.width / 2, 580);
        
        return canvas.toDataURL('image/png');
      },

      async downloadImage(dataUrl) {
        const link = document.createElement('a');
        link.download = `dalorf-results-${Date.now()}.png`;
        link.href = dataUrl;
        link.click();
      },

      async shareImage(dataUrl) {
        try {
          const blob = await (await fetch(dataUrl)).blob();
          const file = new File([blob], 'dalorf-results.png', { type: 'image/png' });
          
          if (navigator.share && navigator.canShare({ files: [file] })) {
            await navigator.share({
              title: 'DALORF Challenge Results',
              text: `Check out our DALORF friendship challenge results! ü™®üêü`,
              files: [file]
            });
            return true;
          }
          return false;
        } catch (error) {
          console.error('Error sharing image:', error);
          return false;
        }
      }
    };

    const gameManager = {
      async createRoom() {
  const createBtn = document.querySelector('button[onclick="createRoom()"]');
  const joinBtn = document.querySelector('button[onclick="joinRoom()"]');
  
  if (!createBtn) {
    console.error('Create button not found');
    return;
  }
  
  const originalText = createBtn.textContent;
  
  // Disable BOTH buttons during creation to prevent double-submission
  createBtn.disabled = true;
  if (joinBtn) joinBtn.disabled = true;
  createBtn.textContent = 'Creating...';
  
  const playerNameInput = document.getElementById('playerName');
  const roomCodeInput = document.getElementById('roomCode');
  
  
  // Get and sanitize inputs
  const playerName = utils.sanitizeInput(playerNameInput.value, APP_CONFIG.MAX_NAME_LENGTH);
  const customCode = utils.sanitizeInput(roomCodeInput.value, APP_CONFIG.MAX_ROOM_CODE_LENGTH).toUpperCase();
  
  // ===== VALIDATION IN CORRECT ORDER =====
  
  // 1. Validate player name first
  if (!playerName) {
    utils.showError('room-error', '‚ùå Please enter your name');
    playerNameInput.focus();
    playerNameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    createBtn.disabled = false;
    createBtn.textContent = originalText;
    return;
  }
  
  if (playerName.length < 2) {
    utils.showError('room-error', '‚ùå Name must be at least 2 characters');
    playerNameInput.focus();
    playerNameInput.select();
    playerNameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    createBtn.disabled = false;
    createBtn.textContent = originalText;
    return;
  }
  
  // 2. Validate custom room code format if provided
  if (customCode) {
    if (customCode.length < 3) {
      utils.showError('room-error', '‚ùå Custom room code must be at least 3 characters');
      roomCodeInput.focus();
      roomCodeInput.select();
      roomCodeInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
      createBtn.disabled = false;
      createBtn.textContent = originalText;
      return;
    }
    
    if (!/^[A-Z0-9]+$/.test(customCode)) {
      utils.showError('room-error', '‚ùå Room code can only contain letters and numbers');
      roomCodeInput.focus();
      roomCodeInput.select();
      roomCodeInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
      createBtn.disabled = false;
      createBtn.textContent = originalText;
      return;
    }
  }
  
  // Set game state after validation
gameState.playerName = playerName;

// Generate or use custom room code
gameState.roomCode = customCode || utils.generateRoomCode();
roomCodeInput.value = gameState.roomCode;

try {
  if (!window.db) {
    throw new Error('Database not available');
  }

  // 3. Check if custom code already exists
  if (customCode) {
    const existingRoom = await window.db.ref(`rooms/${gameState.roomCode}/settings`).once('value');
    if (existingRoom.exists()) {
      utils.showError('room-error', `‚ùå Room code "${gameState.roomCode}" already exists. Please choose a different code or leave empty for auto-generation.`);
      roomCodeInput.focus();
      roomCodeInput.select();
      roomCodeInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
      createBtn.disabled = false;
      createBtn.textContent = originalText;
      return;
    }
  }

  // ===== CREATE ROOM SUCCESSFULLY =====
    
    // Create session for stats tracking (if authenticated)
    let sessionId = null;
    if (userState.userId && !userState.isAnonymous) {
      sessionId = await statsManager.createSession(gameState.roomCode);
    }
    
    // Create room in database
    await window.db.ref(`rooms/${gameState.roomCode}/settings`).set({
      creator: gameState.playerName,
      createdAt: Date.now(),
      sessionId: sessionId,
      creatorUserId: userState.userId || null,
      roomCode: gameState.roomCode,
      roomStatus: 'waiting_for_player', // NEW: Track room status
      createdTimestamp: Date.now() // NEW: For timeout tracking
    });
    
    // NEW: Initialize empty join requests node
    await window.db.ref(`rooms/${gameState.roomCode}/joinRequests`).set({});
    
    // Update game state
    await dbManager.updateGameState(GAME_STATES.SETUP);
    
    // Set up listeners
    dbManager.listenForGameStateChanges();
    gameManager.listenForJoinRequests(); // NEW: Listen for join requests
    
    // Update room info display
    dbManager.updateRoomInfo();
    
    // Save session for reconnection
    sessionManager.saveSession();
    
    // Clear any previous errors first
    const errorEl = document.getElementById('room-error');
    if (errorEl) errorEl.classList.add('hidden');
    
    // Show success message with emphasis
    utils.showSuccess('room-error', `‚úÖ Room created: ${gameState.roomCode}`);
    utils.announceToScreenReader(`Room created with code ${gameState.roomCode}`);
    
    // Show prominent notification with room code and instructions
    setTimeout(() => {
      utils.showNotification(
        `üéâ Room ${gameState.roomCode} created!\n\n` +
        `üìã Share this code with your friend\n` +
        `‚è≥ They can join by entering the code and clicking "Join Room"`,
        8000
      );
    }, 500);
    
    // Auto-select room code for easy copying
    const roomCodeInput = document.getElementById('roomCode');
    if (roomCodeInput && roomCodeInput.value) {
      setTimeout(() => {
        roomCodeInput.select();
      }, 1000);
    }
    
   // Move to join request waiting screen
    this.showSection('join-request-section');
    document.getElementById('waiting-room-code').textContent = gameState.roomCode;
    gameManager.startWaitingTimer('wait-duration');
    
    // Set up auto-timeout for room (2 minutes)
    gameState.roomTimeout = setTimeout(() => {
      const container = document.getElementById('join-requests-container');
      if (container && container.children.length === 0) {
        utils.showNotification('‚è∞ Room timed out - No one joined', 6000);
        setTimeout(() => location.reload(), 2000);
      }
    }, 120000); // 2 minutes
    
    console.log('‚úÖ Room created successfully:', {
      code: gameState.roomCode,
      creator: gameState.playerName,
      sessionId: sessionId
    });
    
  } catch (error) {
    console.error('Error creating room:', error);
    
    // Provide more specific error messages with recovery actions
    let errorMessage = '';
    let showRetryButton = false;
    
    if (error.message.includes('Database not available')) {
      errorMessage = '‚ùå Connection error. Please check your internet and try again.';
      showRetryButton = true;
    } else if (error.message.includes('permission') || error.code === 'PERMISSION_DENIED') {
      errorMessage = '‚ùå Permission denied. Please refresh the page and sign in again.';
    } else if (error.message.includes('network') || error.code === 'NETWORK_ERROR') {
      errorMessage = '‚ùå Network error. Please check your internet connection.';
      showRetryButton = true;
    } else if (error.message.includes('already exists')) {
      errorMessage = error.message; // Use our custom message
      // Don't clear room code input - let user modify it
    } else {
      errorMessage = `‚ùå Failed to create room: ${error.message || 'Unknown error'}. Please try again.`;
      showRetryButton = true;
    }
    
    utils.showError('room-error', errorMessage);
    
    // Only reset room code if it's not a "already exists" error
    if (!error.message.includes('already exists')) {
      gameState.roomCode = null;
      if (!customCode) {
        roomCodeInput.value = ''; // Only clear if it was auto-generated
      }
    }
    
    // Add retry hint for recoverable errors
    if (showRetryButton) {
      setTimeout(() => {
        const errorEl = document.getElementById('room-error');
        if (errorEl && errorEl.textContent.includes(errorMessage)) {
          errorEl.innerHTML += '<br><small style="opacity: 0.8;">üí° Tip: Try refreshing the page if this persists</small>';
        }
      }, 500);
    }
    
  } finally {
    // Re-enable both buttons
    createBtn.disabled = false;
    if (joinBtn) joinBtn.disabled = false;
    createBtn.textContent = originalText;
  }
},

      async joinRoom() {
  const joinBtn = document.querySelector('button[onclick="joinRoom()"]');
  const createBtn = document.querySelector('button[onclick="createRoom()"]');
  
  if (!joinBtn) {
    console.error('Join button not found');
    return;
  }
  
  const originalText = joinBtn.textContent;
  
  // Disable BOTH buttons to prevent double-submission
  joinBtn.disabled = true;
  if (createBtn) createBtn.disabled = true;
  joinBtn.textContent = 'Joining...';
  
  const playerNameInput = document.getElementById('playerName');
  const roomCodeInput = document.getElementById('roomCode');
  
  if (!playerNameInput || !roomCodeInput) {
    console.error('Required input elements not found');
    joinBtn.disabled = false;
    if (createBtn) createBtn.disabled = false;
    joinBtn.textContent = originalText;
    return;
  }
  
  // Get and sanitize inputs
  const playerName = utils.sanitizeInput(playerNameInput.value, APP_CONFIG.MAX_NAME_LENGTH);
  const roomCode = utils.sanitizeInput(roomCodeInput.value, APP_CONFIG.MAX_ROOM_CODE_LENGTH).toUpperCase();
  
  // ===== PHASE 1: CLIENT-SIDE VALIDATION (Fast fails, no DB calls) =====
  
  // 1.1 Validate room code format first (empty check)
  if (!roomCode) {
    utils.showError('room-error', '‚ùå Please enter a room code to join');
    roomCodeInput.focus();
    roomCodeInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    joinBtn.disabled = false;
    if (createBtn) createBtn.disabled = false;
    joinBtn.textContent = originalText;
    return;
  }
  
  // 1.2 Validate room code length
  if (roomCode.length < 3) {
    utils.showError('room-error', '‚ùå Room code is too short (minimum 3 characters)');
    roomCodeInput.focus();
    roomCodeInput.select();
    roomCodeInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    joinBtn.disabled = false;
    if (createBtn) createBtn.disabled = false;
    joinBtn.textContent = originalText;
    return;
  }
  
  // 1.3 Validate room code format (alphanumeric only)
  if (!/^[A-Z0-9]+$/.test(roomCode)) {
    utils.showError('room-error', '‚ùå Room code can only contain letters and numbers');
    roomCodeInput.focus();
    roomCodeInput.select();
    roomCodeInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    joinBtn.disabled = false;
    if (createBtn) createBtn.disabled = false;
    joinBtn.textContent = originalText;
    return;
  }
  
  // 1.4 Validate player name (empty check)
  if (!playerName) {
    utils.showError('room-error', '‚ùå Please enter your name before joining');
    playerNameInput.focus();
    playerNameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    joinBtn.disabled = false;
    if (createBtn) createBtn.disabled = false;
    joinBtn.textContent = originalText;
    return;
  }
  
  // 1.5 Validate player name length
  if (playerName.length < 2) {
    utils.showError('room-error', '‚ùå Name must be at least 2 characters');
    playerNameInput.focus();
    playerNameInput.select();
    playerNameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    joinBtn.disabled = false;
    if (createBtn) createBtn.disabled = false;
    joinBtn.textContent = originalText;
    return;
  }
  
  // 1.6 Validate player name format (no special characters that could break Firebase paths)
  if (/[.$#\[\]\/]/.test(playerName)) {
    utils.showError('room-error', '‚ùå Name cannot contain special characters: . $ # [ ] /');
    playerNameInput.focus();
    playerNameInput.select();
    playerNameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
    joinBtn.disabled = false;
    if (createBtn) createBtn.disabled = false;
    joinBtn.textContent = originalText;
    return;
  }
  
  // ===== PHASE 2: DATABASE VALIDATION (Network calls - do NOT set gameState yet) =====
  
  try {
    // 2.1 Check Firebase availability
    if (!window.db) {
      throw new Error('Database not available');
    }

    // Show checking status (visual feedback for network operation)
    utils.showSuccess('room-error', `üîç Checking room "${roomCode}"...`);

    // 2.1.5 Check if player was permanently rejected from this room
    const rejectionSnapshot = await window.db.ref(`rooms/${roomCode}/rejections/${playerName}`).once('value');
    const rejection = rejectionSnapshot.val();
    
    if (rejection && rejection.permanent) {
      utils.showError('room-error', 
        `üö´ You have been blocked from joining room "${roomCode}".\n\n` +
        `Please try a different room code or create your own room.`
      );
      roomCodeInput.focus();
      roomCodeInput.select();
      roomCodeInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
      joinBtn.disabled = false;
      if (createBtn) createBtn.disabled = false;
      joinBtn.textContent = originalText;
      return;
    }
    
    // Check if player needs to wait before retrying
    if (rejection && !rejection.permanent && rejection.canRetryAfter) {
      const waitTime = rejection.canRetryAfter - Date.now();
      if (waitTime > 0) {
        const seconds = Math.ceil(waitTime / 1000);
        utils.showError('room-error', 
          `‚è∏Ô∏è Please wait ${seconds} second${seconds > 1 ? 's' : ''} before trying to join again.`
        );
        joinBtn.disabled = false;
        if (createBtn) createBtn.disabled = false;
        joinBtn.textContent = originalText;
        return;
      }
    }

    // 2.2 CRITICAL: Check if room exists FIRST (before any other DB operations)
    const roomSnapshot = await window.db.ref(`rooms/${roomCode}/settings`).once('value');
    
    if (!roomSnapshot.exists()) {
      utils.showError('room-error', 
        `‚ùå Room "${roomCode}" does not exist.\n\n` +
        `Please check the code and try again, or create a new room.`
      );
      roomCodeInput.focus();
      roomCodeInput.select();
      roomCodeInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
      joinBtn.disabled = false;
      if (createBtn) createBtn.disabled = false;
      joinBtn.textContent = originalText;
      return;
    }
    
    const roomSettings = roomSnapshot.val();
    
    // 2.3 Get existing players in the room
    const gameStateSnapshot = await window.db.ref(`rooms/${roomCode}/gameState`).once('value');
    const existingPlayers = gameStateSnapshot.val();
    const playerList = existingPlayers ? Object.keys(existingPlayers) : [];
    
    console.log('üìã Room state:', {
      roomCode: roomCode,
      existingPlayers: playerList,
      attemptingToJoin: playerName,
      capacity: `${playerList.length}/2`
    });
    
    // 2.4 Determine if user is reconnecting or joining fresh
    const alreadyInRoom = playerList.includes(playerName);
    
    if (alreadyInRoom) {
      // ===== RECONNECTION SCENARIO =====
      console.log('‚úÖ Player reconnecting to their game:', playerName);
      
      // Check current game state
      const myGameState = existingPlayers[playerName];
      const isGameActive = myGameState && 
                           myGameState.state !== GAME_STATES.SETUP &&
                           myGameState.state !== GAME_STATES.COMPLETED;
      
      // Show reconnection confirmation with detailed info
      const stateDescription = myGameState?.state ? 
        ` (Current state: ${myGameState.state})` : '';
      
      const message = isGameActive 
        ? `üéÆ You have an active game in this room!${stateDescription}\n\n` +
          `Your Options:\n` +
          `‚úÖ Reconnect - Continue your game from where you left off\n` +
          `‚ùå Start Fresh - Delete all progress and start over\n\n` +
          `‚ö†Ô∏è Warning: Starting fresh will lose all your questions and progress!\n\n` +
          `Click OK to RECONNECT, or Cancel to START FRESH.`
        : `üíæ You were previously in this room.${stateDescription}\n\n` +
          `Your Options:\n` +
          `‚úÖ Reconnect - Return to this room\n` +
          `‚ùå Start Fresh - Clear old data and start over\n\n` +
          `Click OK to RECONNECT, or Cancel to START FRESH.`;
      
      const shouldReconnect = confirm(message);
      
      if (!shouldReconnect) {
        // User wants to start fresh - remove old state
        console.log('üîÑ Player chose to start fresh - clearing old data');
        
        utils.showSuccess('room-error', 'üóëÔ∏è Clearing your old data...');
        
        await Promise.all([
          window.db.ref(`rooms/${roomCode}/gameState/${playerName}`).remove(),
          window.db.ref(`rooms/${roomCode}/questions/${playerName}`).remove(),
          window.db.ref(`rooms/${roomCode}/answers/${playerName}`).remove()
        ]);
        
        console.log('‚úÖ Old data cleared successfully');
        utils.showSuccess('room-error', '‚úÖ Old data cleared. Joining fresh...');
      } else {
        console.log('‚Ü©Ô∏è Player chose to reconnect to existing game');
      }
      
    } else {
      // ===== NEW PLAYER JOINING =====
      console.log('üÜï New player attempting to join:', playerName);
      
      // 2.5 Check room capacity (CRITICAL - must enforce 2 player limit)
      if (playerList.length >= 2) {
        const playerNames = playerList.join(' and ');
        utils.showError('room-error', 
          `‚ùå Room "${roomCode}" is full!\n\n` +
          `Current players (2/2):\n` +
          `‚Ä¢ ${playerList[0]}\n` +
          `‚Ä¢ ${playerList[1]}\n\n` +
          `Please:\n` +
          `‚ú® Create a new room instead, or\n` +
          `üîç Ask for a different room code`
        );
        roomCodeInput.focus();
        roomCodeInput.select();
        roomCodeInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        joinBtn.disabled = false;
        if (createBtn) createBtn.disabled = false;
        joinBtn.textContent = originalText;
        return;
      }
      
      // 2.6 Check for name collision within room
      const nameCollision = playerList.some(existingName => 
        existingName.toLowerCase() === playerName.toLowerCase()
      );
      
      if (nameCollision) {
        utils.showError('room-error', 
          `‚ùå Name "${playerName}" is already taken in this room.\n\n` +
          `Please choose a different name.`
        );
        playerNameInput.focus();
        playerNameInput.select();
        playerNameInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        joinBtn.disabled = false;
        if (createBtn) createBtn.disabled = false;
        joinBtn.textContent = originalText;
        return;
      }
      
      console.log('‚úÖ Room has space - proceeding with join');
    }
    
    // ===== PHASE 3: ALL VALIDATION PASSED - SET GAME STATE =====
    // This is the ONLY place we set gameState - after all checks pass
    console.log('‚úÖ All validation passed - setting game state');
    
    gameState.playerName = playerName;
    gameState.roomCode = roomCode;
    
    // ===== PHASE 4: JOIN SUCCESSFUL - SEND JOIN REQUEST =====
    
    // 4.1 Check if room is still accepting players
    if (roomSettings.roomStatus === 'game_started') {
      utils.showError('room-error', '‚ùå This game has already started. Please create a new room.');
      joinBtn.disabled = false;
      if (createBtn) createBtn.disabled = false;
      joinBtn.textContent = originalText;
      return;
    }
    
    // 4.2 Send join request to room
    console.log('üì§ Sending join request to room:', roomCode);
    
    const joinRequestData = {
      playerName: playerName,
      userId: userState.userId || null,
      timestamp: Date.now(),
      rejectedOnce: false // Track if they've been rejected before
    };
    
    await window.db.ref(`rooms/${roomCode}/joinRequests/${playerName}`).set(joinRequestData);
    
    // 4.3 Show waiting for acceptance screen
    this.showSection('waiting-acceptance-section');
    document.getElementById('acceptance-room-code').textContent = roomCode;
    document.getElementById('acceptance-host-name').textContent = roomSettings.creator || 'host';
    gameManager.startWaitingTimer('acceptance-duration');
    
    // 4.4 Listen for acceptance/rejection
    gameManager.listenForJoinResponse(playerName, roomCode);
    
    // 4.5 Update room info display (but don't save session yet - wait for acceptance)
    dbManager.updateRoomInfo();
    
    // 4.6 Show success message
    utils.showSuccess('room-error', `üì§ Join request sent to ${roomSettings.creator || 'host'}`);
    utils.announceToScreenReader(`Join request sent, waiting for acceptance`);
    
    // 4.7 Determine next screen based on game state
    if (roomSettings.requiredQuestionCount && roomSettings.requiredQuestionCount > 0) {
      // Game setup already done by creator - go to appropriate screen
      gameState.requiredQuestionCount = roomSettings.requiredQuestionCount;
      
      if (alreadyInRoom) {
        // Reconnecting - check what state we were in
        const myState = existingPlayers[playerName];
        if (myState && myState.state) {
          console.log('‚Ü©Ô∏è Resuming from state:', myState.state);
          await sessionManager.resumeFromState(myState.state);
        } else {
          // Default to question mode
          console.log('üìù No saved state - entering question mode');
          gameManager.enterQuestionMode();
        }
      } else {
        // New join - go to question mode
        console.log('üìù Joined game in progress - entering question mode');
        gameManager.enterQuestionMode();
      }
    } else {
      // Wait for room creator to set up the game
      console.log('‚è≥ Waiting for room creator to configure game');
      gameManager.showSection('waiting-section');
      document.getElementById('waiting-section').innerHTML = 
        '<div class="loading-indicator">' +
        '‚è≥ Waiting for room creator to set up the game...<br>' +
        '<span style="font-size: 0.9rem; opacity: 0.8;">They need to choose the number of questions</span>' +
        '</div>';
      
      gameManager.listenForRoomUpdates();
    }
    
    console.log('‚úÖ Join room completed successfully:', {
      player: playerName,
      room: roomCode,
      playerCount: playerList.length + 1
    });
    
  } catch (error) {
    // ===== PHASE 5: ERROR HANDLING =====
    console.error('‚ùå Error joining room:', error);
    
    // Provide specific error messages based on error type
    let errorMessage = '';
    let shouldClearInputs = false;
    
    if (error.message.includes('Database not available')) {
      errorMessage = '‚ùå Connection Error\n\n' +
                    'Cannot connect to the game server.\n' +
                    'Please check your internet connection and try again.';
      shouldClearInputs = false;
    } else if (error.message.includes('permission') || error.code === 'PERMISSION_DENIED') {
      errorMessage = '‚ùå Permission Denied\n\n' +
                    'You don\'t have permission to access this room.\n' +
                    'Please refresh the page and sign in again.';
      shouldClearInputs = true;
    } else if (error.message.includes('network') || error.code === 'NETWORK_ERROR') {
      errorMessage = '‚ùå Network Error\n\n' +
                    'Lost connection to the server.\n' +
                    'Please check your internet and try again.';
      shouldClearInputs = false;
    } else if (error.message.includes('full')) {
      errorMessage = error.message; // Use our custom room full message
      shouldClearInputs = false;
    } else if (error.message.includes('does not exist')) {
      errorMessage = error.message; // Use our custom room not found message
      shouldClearInputs = false;
    } else {
      errorMessage = `‚ùå Failed to join room\n\n` +
                    `${error.message || 'Unknown error occurred'}\n\n` +
                    `Please try again or create a new room.`;
      shouldClearInputs = false;
    }
    
    utils.showError('room-error', errorMessage);
    
    // Clean up on critical errors
    if (shouldClearInputs) {
      playerNameInput.value = '';
      roomCodeInput.value = '';
      gameState.playerName = null;
      gameState.roomCode = null;
    }
    
    // Add recovery hint for network errors
    if (error.message.includes('network') || error.message.includes('Connection')) {
      setTimeout(() => {
        const errorEl = document.getElementById('room-error');
        if (errorEl && errorEl.textContent.includes('Connection')) {
          const hint = document.createElement('div');
          hint.style.cssText = 'margin-top: 12px; font-size: 0.9rem; opacity: 0.8;';
          hint.innerHTML = 'üí° <strong>Tip:</strong> Try refreshing the page if this persists';
          errorEl.appendChild(hint);
        }
      }, 500);
    }
    
  } finally {
    // ===== PHASE 6: CLEANUP =====
    // Always re-enable buttons, regardless of success or failure
    joinBtn.disabled = false;
    if (createBtn) createBtn.disabled = false;
    joinBtn.textContent = originalText;
    
    console.log('üîß Join room cleanup completed');
  }
},

      async startGameSetup() {
        gameState.requiredQuestionCount = parseInt(document.getElementById('questionCount').value);
        
        try {
          if (!window.db) {
            throw new Error('Database not available');
          }

          await window.db.ref(`rooms/${gameState.roomCode}/settings`).update({
            requiredQuestionCount: gameState.requiredQuestionCount
          });
          
          // Save current round info
          if (userState.sessionId) {
            await window.db.ref(`sessions/${userState.sessionId}`).update({
              currentRound: gameState.currentRound,
              lastActivity: Date.now()
            });
          }
          
          this.enterQuestionMode();
        } catch (error) {
          console.error('Error starting game setup:', error);
          utils.showError('question-error', 'Failed to save game settings. Please try again.');
        }
      },

      enterQuestionMode() {
        this.showSection('question-section');
        
        dbManager.updateGameState(GAME_STATES.CREATING_QUESTIONS);
        
        document.querySelector('#question-section h3').textContent = 
          `Add Your Questions (${gameState.requiredQuestionCount} required)`;
        
        this.addQuestion();
        utils.announceToScreenReader('Now in question creation mode');
      },

      showSection(sectionId) {
  document.querySelectorAll('.section').forEach(section => {
    section.classList.add('hidden');
  });
  
  const targetSection = document.getElementById(sectionId);
  if (targetSection) {
    targetSection.classList.remove('hidden');
    
    // Auto-focus first available input
    setTimeout(() => {
      const firstInput = targetSection.querySelector('input:not([disabled]):not([type="radio"]), select:not([disabled])');
      if (firstInput) {
        firstInput.focus();
        // Scroll into view if needed
        firstInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }, 150);
  }
},

      generateAutomatedQuestions() {
        const intensity = document.querySelector('input[name="intensity"]:checked').value;
        const questions = AUTOMATED_QUESTIONS[intensity];
        const suggestedContainer = document.getElementById('suggested-questions');
        
        const randomQuestions = questions.sort(() => 0.5 - Math.random()).slice(0, 3);
        
        suggestedContainer.innerHTML = '<h5>Suggested Questions:</h5>' + 
          randomQuestions.map((q, i) => 
            `<div style="margin: 12px 0; padding: 12px; border-left: 3px solid var(--color-accent); background: color-mix(in srgb, var(--color-accent) 5%, transparent); border-radius: 4px;">
              <strong>${q.q}</strong><br>
              <small style="opacity: 0.8;">Options: ${q.opts.join(', ')}</small><br>
              <button onclick="gameManager.useAutomatedQuestion(${JSON.stringify(q).replace(/"/g, '&quot;')})" 
                      style="margin-top: 8px; font-size: 0.9rem; padding: 6px 12px;">
                Use This Question
              </button>
            </div>`
          ).join('');
      },

      useAutomatedQuestion(questionData) {
        const qData = {
          question: questionData.q,
          options: questionData.opts,
          correct: ""
        };
        this.addQuestion(qData);
      },

      addQuestion(qData = null) {
        const container = document.getElementById('questions-container');
        const currentCount = container.children.length;

// Update question counter in heading
const sectionHeading = document.querySelector('#question-section h3');
if (sectionHeading && !sectionHeading.textContent.includes('Review')) {
  sectionHeading.textContent = `Add Your Questions (${currentCount}/${gameState.requiredQuestionCount})`;
}

if (currentCount >= gameState.requiredQuestionCount * APP_CONFIG.MAX_QUESTIONS_MULTIPLIER) {
          utils.showError('question-error', `Maximum ${gameState.requiredQuestionCount * APP_CONFIG.MAX_QUESTIONS_MULTIPLIER} questions allowed`);
          return;
        }
        
        const questionIndex = currentCount + 1;
        const div = document.createElement('div');
        div.className = 'question-block';
        div.setAttribute('role', 'group');
        div.setAttribute('aria-labelledby', `question-${questionIndex}-label`);
        
        div.innerHTML = `
          <h4 id="question-${questionIndex}-label" class="sr-only">Question ${questionIndex}</h4>
          <label for="question-${questionIndex}-text" class="sr-only">Question text</label>
          <input id="question-${questionIndex}-text" 
                 class="main-question-input" 
                 placeholder="e.g. What is my favorite color?" 
                 aria-label="Question ${questionIndex} text"
                 value="${qData ? qData.question : ''}"
                 maxlength="200">
          
          <label for="option-${questionIndex}-1" class="sr-only">Option 1</label>
          <input id="option-${questionIndex}-1"
                 placeholder="Option 1 (e.g. Blue)" 
                 class="option-input" 
                 aria-label="Option 1 for question ${questionIndex}"
                 value="${qData ? qData.options[0] : ''}"
                 maxlength="100">
          
          <label for="option-${questionIndex}-2" class="sr-only">Option 2</label>
          <input id="option-${questionIndex}-2"
                 placeholder="Option 2 (e.g. Red)" 
                 class="option-input" 
                 aria-label="Option 2 for question ${questionIndex}"
                 value="${qData ? qData.options[1] : ''}"
                 maxlength="100">
          
          <label for="option-${questionIndex}-3" class="sr-only">Option 3</label>
          <input id="option-${questionIndex}-3"
                 placeholder="Option 3 (e.g. Green)" 
                 class="option-input" 
                 aria-label="Option 3 for question ${questionIndex}"
                 value="${qData ? qData.options[2] : ''}"
                 maxlength="100">
          
          <label for="option-${questionIndex}-4" class="sr-only">Option 4</label>
          <input id="option-${questionIndex}-4"
                 placeholder="Option 4 (e.g. Yellow)" 
                 class="option-input" 
                 aria-label="Option 4 for question ${questionIndex}"
                 value="${qData ? qData.options[3] : ''}"
                 maxlength="100">
          
          <label for="correct-${questionIndex}" class="sr-only">Correct answer for question ${questionIndex}</label>
          <select id="correct-${questionIndex}" aria-label="Correct answer for question ${questionIndex}">
            <option value="">Select Correct Answer</option>
            <option value="1" ${qData && qData.correct == "1" ? "selected" : ""}>Option 1</option>
            <option value="2" ${qData && qData.correct == "2" ? "selected" : ""}>Option 2</option>
            <option value="3" ${qData && qData.correct == "3" ? "selected" : ""}>Option 3</option>
            <option value="4" ${qData && qData.correct == "4" ? "selected" : ""}>Option 4</option>
          </select>
          
          <div style="margin-top: 12px;">
            <button class="edit-btn hidden" aria-label="Edit question ${questionIndex}">Edit</button>
            <button class="delete-btn" aria-label="Delete question ${questionIndex}">Delete</button>
          </div>
        `;
        
        container.appendChild(div);

        div.querySelector('.delete-btn').onclick = () => {
          div.remove();
          utils.announceToScreenReader(`Question ${questionIndex} deleted`);
        };
        
        div.querySelector('.edit-btn').onclick = () => {
          Array.from(div.querySelectorAll('input, select')).forEach(el => el.disabled = false);
          div.querySelector('.edit-btn').classList.add('hidden');
          utils.announceToScreenReader(`Question ${questionIndex} unlocked for editing`);
        };
        
        if (!qData) {
          div.querySelector('.main-question-input').focus();
        }
      },

      async submitQuestions() {
        const blocks = document.querySelectorAll('.question-block');
        
        if (blocks.length < gameState.requiredQuestionCount) {
          utils.showError('question-error', `Please add at least ${gameState.requiredQuestionCount} questions before submitting`);
          return;
        }

        let questions = [];
        let hasErrors = false;
        
        blocks.forEach((block, index) => {
          const questionInput = block.querySelector('.main-question-input');
          const optionInputs = block.querySelectorAll('.option-input');
          const correctSelect = block.querySelector('select');
          
          const q = questionInput.value.trim();
          const opts = Array.from(optionInputs).map(o => o.value.trim());
          const correct = correctSelect.value;
          
          if (!q) {
            utils.showError('question-error', `Question ${index + 1}: Please enter a question`);
            questionInput.focus();
            hasErrors = true;
            return;
          }
          
          if (!opts.every(o => o)) {
            utils.showError('question-error', `Question ${index + 1}: Please fill out all 4 options`);
            const emptyOption = optionInputs[opts.findIndex(o => !o)];
            if (emptyOption) emptyOption.focus();
            hasErrors = true;
            return;
          }
          
          if (!correct) {
            utils.showError('question-error', `Question ${index + 1}: Please select the correct answer`);
            correctSelect.focus();
            hasErrors = true;
            return;
          }
          
          questions.push({ question: q, options: opts, correct });
        });
        
        questions = questions.slice(0, gameState.requiredQuestionCount);
        
        if (hasErrors || questions.length < gameState.requiredQuestionCount) return;

        const submitBtn = document.getElementById('submit-btn');
        submitBtn.disabled = true;
        submitBtn.textContent = 'Submitting...';
        
        try {
          if (!window.db) {
            throw new Error('Database not available');
          }

          await Promise.all([
            window.db.ref(`rooms/${gameState.roomCode}/questions/${gameState.playerName}`).set(questions),
            dbManager.updateGameState(GAME_STATES.QUESTIONS_SUBMITTED)
          ]);
          
          utils.showSuccess('question-error', 'Questions submitted! You now have 1 minute to review and make changes.');
          gameState.reviewEndTime = Date.now() + APP_CONFIG.REVIEW_TIME_MS;
          gameState.reviewCompleted = false;
          this.startReviewTimer();
          utils.announceToScreenReader('Questions submitted successfully. Review period started.');
          
        } catch (error) {
          console.error('Error submitting questions:', error);
          utils.showError('question-error', 'Failed to save your questions. Please try again.');
          submitBtn.disabled = false;
          submitBtn.textContent = 'Submit Questions';
        }
      },

      startReviewTimer() {
        const reviewTimerDiv = document.getElementById('review-timer-visible');
        const timerEl = document.getElementById('timer-visible');
        
        reviewTimerDiv.style.display = 'inline';
        reviewTimerDiv.classList.remove('hidden');
        
        document.querySelectorAll('.question-block input, .question-block select').forEach(el => {
          el.disabled = false;
        });
        
        gameState.isReviewPaused = false;

        const updateTimer = () => {
          if (gameState.isReviewPaused) return;
          
          const diff = gameState.reviewEndTime - Date.now();
          
          if (diff <= 0) {
            clearInterval(gameState.reviewInterval);
            gameState.reviewCompleted = true;
            
            // Update the review timer to show waiting message
            reviewTimerDiv.innerHTML = 
              '‚è∞ Your review completed! Waiting for other player... <span id="wait-after-review" class="timer"></span>';
            
            // Disable all inputs
            document.querySelectorAll('.question-block input, .question-block select').forEach(el => {
              el.disabled = true;
            });
            document.querySelectorAll('.edit-btn').forEach(btn => {
              btn.classList.remove('hidden');
            });
            
            // Hide add question and resubmit buttons
            document.querySelectorAll('#question-section button').forEach(btn => {
              if (btn.id !== 'pause-edit-btn' && !btn.classList.contains('edit-btn') && !btn.classList.contains('delete-btn')) {
                btn.style.display = 'none';
              }
            });
            
            // Start a wait timer
            this.startPostReviewWaitTimer();
            
            dbManager.updateGameState(GAME_STATES.REVIEW_COMPLETED).then(() => {
              utils.showNotification("üïí Your review time ended! Waiting for other player...");
              utils.announceToScreenReader('Review time ended. Waiting for other player.', true);
            });
          } else {
            timerEl.textContent = utils.formatTime(diff);
            
            if (diff < 30000) {
              timerEl.classList.add('low-time');
              if (diff <= 10000 && Math.floor((diff % 60000) / 1000) % 5 === 0) {
                utils.announceToScreenReader(`${Math.floor(diff / 1000)} seconds remaining`, true);
              }
            }
          }
        };

        gameState.reviewInterval = setInterval(updateTimer, 1000);
        updateTimer();
      },

      startPostReviewWaitTimer() {
        const waitStart = Date.now();
        const waitTimerEl = document.getElementById('wait-after-review');
        
        const updateWaitTimer = () => {
          if (!waitTimerEl) return;
          
          const diff = Date.now() - waitStart;
          const minutes = Math.floor(diff / 60000);
          const seconds = Math.floor((diff % 60000) / 1000);
          waitTimerEl.textContent = `(${minutes}:${seconds < 10 ? '0' + seconds : seconds})`;
          
          // Check if we're still in question section
          if (!document.getElementById('question-section').classList.contains('hidden')) {
            setTimeout(updateWaitTimer, 1000);
          }
        };
        
        updateWaitTimer();
      },

      pauseAndEdit() {
        gameState.isReviewPaused = true;
        clearInterval(gameState.reviewInterval);
        
        document.getElementById('review-timer-visible').innerHTML = 
          '‚è∏Ô∏è Timer Paused - Make your changes and resubmit when ready';
        
        const submitBtn = document.getElementById('submit-btn');
        submitBtn.disabled = false;
        submitBtn.textContent = 'Resubmit Questions';
        
        utils.showNotification("Timer paused! Make your changes and resubmit.");
        utils.announceToScreenReader('Timer paused. You can now make changes.');
      },

      transitionToAnswering() {
        const currentSection = document.querySelector('.section:not(.hidden)');
        if (currentSection?.id === 'answer-section') {
          return;
        }
        
        utils.showNotification("üéØ Both players ready! Loading questions...");
        
        if (gameState.reviewCompleted && gameState.reviewInterval) {
          clearInterval(gameState.reviewInterval);
        }
        
        setTimeout(() => {
          this.startAnswering();
        }, 1500);
      },

      async startAnswering() {
        await dbManager.updateGameState(GAME_STATES.ANSWERING);
        
        this.showSection('answer-section');
        document.getElementById('waiting-answers').classList.remove('hidden');
        
        utils.announceToScreenReader('Loading questions to answer...');
        
        try {
          if (!window.db) {
            throw new Error('Database not available');
          }

          const snapshot = await window.db.ref(`rooms/${gameState.roomCode}/questions`).once('value');
          const allQuestions = snapshot.val();
          
          if (!allQuestions) {
            utils.showError('answer-error', 'No questions found. Please refresh and try again.');
            return;
          }
          
          const otherPlayer = Object.keys(allQuestions).find(name => name !== gameState.playerName);
          
          if (!otherPlayer || !allQuestions[otherPlayer]) {
            this.showSection('waiting-section');
            this.startWaitingTimer();
            this.waitForOtherPlayerQuestions();
            return;
          }
          
          document.getElementById('waiting-section').classList.add('hidden');
          document.getElementById('waiting-answers').classList.add('hidden');
          this.showQuestionsToAnswer(allQuestions[otherPlayer], otherPlayer);
          utils.announceToScreenReader(`Questions loaded from ${otherPlayer}. Ready to answer!`);
          
        } catch (error) {
          console.error('Error loading questions:', error);
          utils.showError('answer-error', 'Error loading questions. Please refresh and try again.');
        }
      },

      startWaitingTimer() {
        gameState.waitStartTime = Date.now();
        const timerEl = document.getElementById('wait-timer');
        
        const updateTimer = () => {
          const diff = Date.now() - gameState.waitStartTime;
          const minutes = Math.floor(diff / 60000);
          const seconds = Math.floor((diff % 60000) / 1000);
          timerEl.textContent = `(${minutes}:${seconds < 10 ? '0' + seconds : seconds})`;
          
          if (!document.getElementById('waiting-section').classList.contains('hidden')) {
            setTimeout(updateTimer, 1000);
          } else {
            timerEl.textContent = '';
          }
        };
        
        updateTimer();
      },

      waitForOtherPlayerQuestions() {
        if (!window.db) return;
        
        const questionsRef = window.db.ref(`rooms/${gameState.roomCode}/questions`);
        const questionListener = questionsRef.on('value', (snapshot) => {
          const allQuestions = snapshot.val();
          if (!allQuestions) return;
          
          const otherPlayer = Object.keys(allQuestions).find(name => name !== gameState.playerName);
          if (otherPlayer && allQuestions[otherPlayer]) {
            questionsRef.off('value', questionListener);
            document.getElementById('waiting-section').classList.add('hidden');
            document.getElementById('waiting-answers').classList.add('hidden');
            this.showQuestionsToAnswer(allQuestions[otherPlayer], otherPlayer);
            utils.announceToScreenReader(`Questions loaded from ${otherPlayer}. Ready to answer!`);
          }
        });
      },

      showQuestionsToAnswer(questions, otherPlayer) {
        const container = document.getElementById('answer-container');
        container.innerHTML = '';
        container.setAttribute('data-other-player', otherPlayer);
        
        questions.forEach((question, index) => {
          const div = document.createElement('div');
          div.className = 'question-block';
          div.setAttribute('role', 'group');
          div.setAttribute('aria-labelledby', `answer-question-${index + 1}`);
          
          div.innerHTML = `
            <h4 id="answer-question-${index + 1}"><strong>${index + 1}. ${question.question}</strong></h4>
            <fieldset style="border: none; padding: 0; margin: 0;">
              <legend class="sr-only">Choose your answer for question ${index + 1}</legend>
              ${question.options.map((option, optionIndex) =>
                `<label style="display: block; margin: 10px 0; cursor: pointer; padding: 8px; border-radius: 4px; transition: background-color 0.2s;">
                  <input type="radio" 
                         name="q${index}" 
                         value="${optionIndex + 1}" 
                         style="margin-right: 10px;"
                         aria-describedby="option-${index}-${optionIndex}"> 
                  <span id="option-${index}-${optionIndex}">${option}</span>
                </label>`
              ).join('')}
            </fieldset>
          `;
          
          container.appendChild(div);
          
          div.querySelectorAll('label').forEach(label => {
            label.addEventListener('mouseenter', () => {
              label.style.backgroundColor = 'color-mix(in srgb, var(--color-accent) 10%, transparent)';
            });
            label.addEventListener('mouseleave', () => {
              label.style.backgroundColor = 'transparent';
            });
          });
        });
      },

      async submitAnswers() {
        const blocks = document.querySelectorAll('#answer-container .question-block');
        let answers = [];
        let hasError = false;
        let firstEmptyQuestion = null;
        
        blocks.forEach((block, index) => {
          const selected = block.querySelector('input[type=radio]:checked');
          if (!selected) {
            hasError = true;
            if (!firstEmptyQuestion) firstEmptyQuestion = index + 1;
          }
          answers.push(selected ? selected.value : null);
        });
        
        if (hasError) {
          utils.showError('answer-error', `Please answer all questions. Missing answer for question ${firstEmptyQuestion}.`);
          const firstEmpty = document.querySelector(`input[name="q${firstEmptyQuestion-1}"]`);
          if (firstEmpty) {
            firstEmpty.focus();
            firstEmpty.closest('.question-block').scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
          return;
        }
        
        document.getElementById('waiting-answers').classList.remove('hidden');
        utils.announceToScreenReader('Submitting answers...');
        
        try {
          if (!window.db) {
            throw new Error('Database not available');
          }

          await Promise.all([
            window.db.ref(`rooms/${gameState.roomCode}/answers/${gameState.playerName}`).set(answers),
            dbManager.updateGameState(GAME_STATES.COMPLETED)
          ]);
          
          this.waitForBothAnswers(answers);
          
        } catch (error) {
          console.error('Error submitting answers:', error);
          utils.showError('answer-error', 'Failed to save your answers. Please try again.');
          document.getElementById('waiting-answers').classList.add('hidden');
        }
      },

      async waitForBothAnswers(myAnswers) {
        const otherPlayer = document.getElementById('answer-container').getAttribute('data-other-player');
        
        try {
          if (!window.db) {
            throw new Error('Database not available');
          }

          const snapshot = await window.db.ref(`rooms/${gameState.roomCode}/answers`).once('value');
          const allAnswers = snapshot.val();
          
          if (allAnswers && allAnswers[gameState.playerName] && allAnswers[otherPlayer]) {
            this.loadQuestionsAndCalculateResults(myAnswers, otherPlayer, allAnswers[otherPlayer]);
          } else {
            const answersRef = window.db.ref(`rooms/${gameState.roomCode}/answers`);
            const answerListener = answersRef.on('value', (snapshot) => {
              const allAnswers = snapshot.val();
              if (allAnswers && allAnswers[gameState.playerName] && allAnswers[otherPlayer]) {
                answersRef.off('value', answerListener);
                this.loadQuestionsAndCalculateResults(myAnswers, otherPlayer, allAnswers[otherPlayer]);
              }
            });
          }
        } catch (error) {
          console.error('Error waiting for answers:', error);
          utils.showError('answer-error', 'Error waiting for other player. Please refresh.');
        }
      },

      async loadQuestionsAndCalculateResults(myAnswers, otherPlayer, otherPlayerAnswers) {
        try {
          if (!window.db) {
            throw new Error('Database not available');
          }

          const snapshot = await window.db.ref(`rooms/${gameState.roomCode}/questions`).once('value');
          const allQuestions = snapshot.val();
          
          if (allQuestions) {
            this.calculateResults(
              myAnswers,
              allQuestions[otherPlayer],
              otherPlayer,
              allQuestions,
              otherPlayerAnswers
            );
            document.getElementById('waiting-answers').classList.add('hidden');
          }
        } catch (error) {
          console.error('Error loading questions for results:', error);
          utils.showError('answer-error', 'Error loading questions for results. Please refresh.');
        }
      },

      async calculateResults(answers, questions, otherPlayer, allQuestions, otherPlayerAnswers = null) {
        let correctCount = 0;
        let breakdown = '';
        
        questions.forEach((q, i) => {
          const isCorrect = answers[i] == q.correct;
          if (isCorrect) correctCount++;
          
          const userAnswer = answers[i] ? q.options[answers[i] - 1] : 'No answer';
          const correctAnswer = q.options[q.correct - 1];
          
          breakdown += `
            <div style="margin: 16px 0; padding: 16px; border-radius: var(--border-radius); background: ${isCorrect ? 'var(--bg-success)' : 'var(--bg-error)'}; border: 1px solid ${isCorrect ? 'var(--border-success)' : 'var(--border-error)'};">
              <p><strong>${i + 1}. ${q.question}</strong></p>
              <p>Your answer: <span style="color: ${isCorrect ? 'var(--text-success)' : 'var(--text-error)'}; font-weight: 600;">${userAnswer}</span> ${isCorrect ? '‚úÖ' : '‚ùå'}</p>
              <p>Correct answer: <span style="color: var(--text-success); font-weight: 600;">${correctAnswer}</span></p>
            </div>
          `;
        });
        
        const percent = Math.round((correctCount / questions.length) * 100);
        const tag = this.getLevelTag(percent);

        // Store my score
        gameState.myScore = percent;
        gameState.myTag = tag;

        let otherBreakdownHTML = '';
        let otherScoreHTML = '';
        let otherCorrectCount = 0;
        
        if (allQuestions && allQuestions[gameState.playerName] && otherPlayerAnswers && Array.isArray(otherPlayerAnswers)) {
          const questionsForOther = allQuestions[gameState.playerName];
          let otherBreakdown = '';
          
          questionsForOther.forEach((q, i) => {
            const isCorrect = otherPlayerAnswers[i] == q.correct;
            if (isCorrect) otherCorrectCount++;
            
            const theirAnswer = otherPlayerAnswers[i] ? q.options[otherPlayerAnswers[i] - 1] : 'No answer';
            const correctAnswer = q.options[q.correct - 1];
            
            otherBreakdown += `
              <div style="margin: 16px 0; padding: 16px; border-radius: var(--border-radius); background: ${isCorrect ? 'var(--bg-success)' : 'var(--bg-error)'}; border: 1px solid ${isCorrect ? 'var(--border-success)' : 'var(--border-error)'};">
                <p><strong>${i + 1}. ${q.question}</strong></p>
                <p>Their answer: <span style="color: ${isCorrect ? 'var(--text-success)' : 'var(--text-error)'}; font-weight: 600;">${theirAnswer}</span> ${isCorrect ? '‚úÖ' : '‚ùå'}</p>
                <p>Correct answer: <span style="color: var(--text-success); font-weight: 600;">${correctAnswer}</span></p>
              </div>
            `;
          });
          
          const otherPercent = Math.round((otherCorrectCount / questionsForOther.length) * 100);
          const otherTag = this.getLevelTag(otherPercent);
          
          // Store other player's score
          gameState.otherScore = otherPercent;
          gameState.otherTag = otherTag;
          
          otherScoreHTML = `<h4 style="margin-top: 32px;">${otherPlayer} scored ${otherPercent}% - ${otherTag}</h4>`;
          otherBreakdownHTML = `<h4>How ${otherPlayer} did on your questions:</h4>` + otherBreakdown;
        }

        if (percent >= 90 || (otherPlayerAnswers && Math.round((otherCorrectCount / allQuestions[gameState.playerName].length) * 100) >= 90)) {
          this.createConfetti();
        }

        this.showSection('result-section');
        document.getElementById('result-output').innerHTML = `
          <div style="text-align: left; max-width: 600px; margin: 0 auto;">
            <h4>${gameState.playerName || 'You'} scored ${percent}% - ${tag}</h4>
            <h4>Your performance on ${otherPlayer}'s questions:</h4>
            ${breakdown}
            ${otherScoreHTML ? `<hr style="margin: 40px 0; border: 1px solid var(--border-input);">${otherScoreHTML}${otherBreakdownHTML}` : ""}
            
            <div style="text-align: center; margin-top: 40px; padding: 24px; background: var(--bg-card); border-radius: var(--border-radius-large); box-shadow: var(--shadow-medium);">
              <h4 style="margin-bottom: 16px;">Share Your Results üéâ</h4>
              ${gameState.opponentUserId ? `
                <button onclick="startNewRound()" style="background: #10B981; width: 100%; font-size: 1.2rem; padding: 16px;">
                  üîÑ Play Another Round with ${otherPlayer}
                </button>
                <hr style="margin: 20px 0; border: 1px solid var(--border-input);">
              ` : ''}
              <div style="display: flex; gap: 12px; justify-content: center; flex-wrap: wrap;">
                <button onclick="shareResults('image')" style="background: #8B5CF6;">
                  üñºÔ∏è Share Image
                </button>
                <button onclick="shareResults('download')" style="background: #10B981;">
                  üíæ Download Image
                </button>
                <button onclick="shareResults('copy')" style="background: #F59E0B;">
                  üìã Copy Text
                </button>
              </div>
              <div id="share-feedback" class="success-message hidden" style="margin-top: 12px;"></div>
            </div>
          </div>
        `;

        utils.announceToScreenReader(`Results ready. You scored ${percent} percent - ${tag}`);
        
        // Save game results to stats (for authenticated users only)
        if (userState.userId && !userState.isAnonymous && gameState.opponentUserId) {
          const otherPercent = otherCorrectCount > 0 ? Math.round((otherCorrectCount / allQuestions[gameState.playerName].length) * 100) : null;
          
          await statsManager.saveGameResults({
            myScore: percent,
            theirScore: otherPercent,
            opponentUserId: gameState.opponentUserId,
            opponentName: otherPlayer,
            roundNumber: gameState.currentRound || 1,
            questionsCount: questions.length
          });
        }
        

        // Show upgrade prompt for anonymous users after first game
        if (userState.isAnonymous && userState.stats && userState.stats.totalGames === 1) {
          setTimeout(() => {
            utils.showNotification('üéâ Great first game! Sign up to save your progress and stats!', 8000);
            setTimeout(() => {
              if (confirm('Want to save your progress? Create a free account now!')) {
                authManager.upgradeAccount();
              }
            }, 2000);
          }, 3000);
        }
        
        this.cleanup();
      },

      

      getLevelTag(percent) {
        if (percent === 100) return "üíé Perfect Harmony";
        if (percent >= 90) return "üíñ Soulmate Energy";
        if (percent >= 80) return "üòä Close Confidant";
        if (percent >= 70) return "ü§ù Good Friends";
        if (percent >= 60) return "üôÇ Getting There";
        if (percent >= 50) return "üòê Friendly Guesswork";
        if (percent >= 40) return "üòÖ We Need to Talk";
        if (percent >= 30) return "üò¨ Strangers Much?";
        if (percent >= 20) return "ü§î Do You Even Know Me?";
        if (percent >= 10) return "üò± Who Are You?";
        return "üëª Ghost Friends";
      },

      createConfetti() {
        for (let i = 0; i < 50; i++) {
          setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.classList.add('confetti');
            confetti.style.left = Math.random() * 100 + 'vw';
            confetti.style.animationDuration = Math.random() * 2 + 2 + 's';
            confetti.style.opacity = Math.random();
            document.body.appendChild(confetti);
            
            setTimeout(() => {
              if (confetti.parentNode) {
                confetti.remove();
              }
            }, 4000);
          }, i * 50);
        }
      },

      cleanup() {
        if (gameState.gameStateListener) {
          gameState.gameStateListener.off();
          gameState.gameStateListener = null;
        }
        
        if (gameState.reviewInterval) {
          clearInterval(gameState.reviewInterval);
        }
        
        if (window.db && gameState.roomCode) {
          setTimeout(() => {
            window.db.ref(`rooms/${gameState.roomCode}`).remove()
              .catch(err => console.error("Failed to clean up game room:", err));
          }, APP_CONFIG.CLEANUP_DELAY_MS);
        }
      },

      listenForJoinRequests() {
        if (!window.db || !gameState.roomCode) return;
        
        const joinRequestsRef = window.db.ref(`rooms/${gameState.roomCode}/joinRequests`);
        
        joinRequestsRef.on('child_added', (snapshot) => {
          const requestData = snapshot.val();
          const playerName = snapshot.key;
          
          // Don't show our own request
          if (playerName === gameState.playerName) return;
          
          this.displayJoinRequest(playerName, requestData);
        });
        
        joinRequestsRef.on('child_removed', (snapshot) => {
          const playerName = snapshot.key;
          this.removeJoinRequestUI(playerName);
        });
        
        // Store reference for cleanup
        gameState.joinRequestsListener = joinRequestsRef;
      },

      displayJoinRequest(playerName, requestData) {
        const container = document.getElementById('join-requests-container');
        
        // Check if already displayed
        if (document.getElementById(`join-request-${playerName}`)) return;
        
        const requestDiv = document.createElement('div');
        requestDiv.id = `join-request-${playerName}`;
        requestDiv.className = 'notification';
        requestDiv.style.cssText = 'margin-bottom: 16px; text-align: left; animation: slideIn 0.4s ease;';
        
        const timeAgo = Math.floor((Date.now() - requestData.timestamp) / 1000);
        const timeText = timeAgo < 5 ? 'Just now' : `${timeAgo}s ago`;
        
        requestDiv.innerHTML = `
          <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 12px;">
            <div style="flex: 1; min-width: 150px;">
              <div style="font-size: 1.1rem; font-weight: 700; margin-bottom: 4px;">
                üë§ ${playerName}
              </div>
              <div style="font-size: 0.85rem; opacity: 0.8;">
                Requested ${timeText}
              </div>
              ${requestData.rejectedOnce ? '<div style="font-size: 0.8rem; color: #ff9800; margin-top: 4px;">‚ö†Ô∏è Previously rejected</div>' : ''}
            </div>
            <div style="display: flex; gap: 8px;">
              <button onclick="acceptPlayer('${playerName}')" 
                      style="background: #10B981; padding: 8px 16px; font-size: 0.9rem;">
                ‚úÖ Accept
              </button>
              <button onclick="rejectPlayer('${playerName}')" 
                      style="background: #ef5350; padding: 8px 16px; font-size: 0.9rem;">
                ‚ùå Reject
              </button>
            </div>
          </div>
        `;
        
        container.appendChild(requestDiv);
        utils.announceToScreenReader(`Join request from ${playerName}`);
      },

      removeJoinRequestUI(playerName) {
        const requestDiv = document.getElementById(`join-request-${playerName}`);
        if (requestDiv) {
          requestDiv.style.animation = 'fadeOut 0.3s ease';
          setTimeout(() => requestDiv.remove(), 300);
        }
      },

      startWaitingTimer(elementId) {
        const startTime = Date.now();
        const timerEl = document.getElementById(elementId);
        
        const updateTimer = () => {
          if (!timerEl || timerEl.offsetParent === null) return; // Stop if element hidden
          
          const elapsed = Date.now() - startTime;
          const minutes = Math.floor(elapsed / 60000);
          const seconds = Math.floor((elapsed % 60000) / 1000);
          timerEl.textContent = `${minutes}:${seconds < 10 ? '0' + seconds : seconds}`;
          
          setTimeout(updateTimer, 1000);
        };
        
        updateTimer();
      },

      listenForRoomUpdates() {
        if (!window.db || !gameState.roomCode) return;
        
        const settingsRef = window.db.ref(`rooms/${gameState.roomCode}/settings`);
        
        const settingsListener = settingsRef.on('value', (snapshot) => {
          const settings = snapshot.val();
          
          if (!settings) return;
          
          // Check if question count has been set
          if (settings.requiredQuestionCount && settings.requiredQuestionCount > 0) {
            gameState.requiredQuestionCount = settings.requiredQuestionCount;
            
            // Remove listener
            settingsRef.off('value', settingsListener);
            
            // Move to question mode
            this.enterQuestionMode();
            utils.showNotification(`üéØ Game setup complete! ${settings.requiredQuestionCount} questions per player`);
          }
        });
      },

      listenForJoinResponse(playerName, roomCode) {
        if (!window.db) return;
        
        // Listen for acceptance
        const acceptanceRef = window.db.ref(`rooms/${roomCode}/acceptances/${playerName}`);
        const acceptanceListener = acceptanceRef.on('value', (snapshot) => {
          const acceptance = snapshot.val();
          
          if (acceptance && acceptance.accepted) {
            // Clean up listeners
            acceptanceRef.off('value', acceptanceListener);
            if (gameState.rejectionListener) {
              gameState.rejectionListener.off();
            }
            
            // Update game state
            dbManager.updateGameState(GAME_STATES.SETUP);
            dbManager.listenForGameStateChanges();
            
            // Save session
            sessionManager.saveSession();
            
            utils.showNotification('‚úÖ Join request accepted! Waiting for game setup...');
            utils.announceToScreenReader('Join request accepted');
            
            // Show waiting or question setup based on room settings
            this.showSection('waiting-section');
            document.getElementById('waiting-section').innerHTML = 
              '<div class="loading-indicator">‚è≥ Waiting for host to configure game...</div>';
            this.listenForRoomUpdates();
          }
        });
        
        // Listen for rejection
        const rejectionRef = window.db.ref(`rooms/${roomCode}/rejections/${playerName}`);
        const rejectionListener = rejectionRef.on('value', (snapshot) => {
          const rejection = snapshot.val();
          
          if (rejection && rejection.rejected) {
            // Clean up listeners
            rejectionRef.off('value', rejectionListener);
            acceptanceRef.off('value', acceptanceListener);
            
            // Remove join request
            window.db.ref(`rooms/${roomCode}/joinRequests/${playerName}`).remove();
            
            if (rejection.permanent) {
              // Permanent rejection
              utils.showError('room-error', 
                `‚ùå Your join request was rejected.\n\n` +
                `You cannot join this room. Please create a new room or try a different code.`
              );
              
              // Clear state
              gameState.playerName = null;
              gameState.roomCode = null;
              sessionManager.clearSession();
              
              // Return to auth section
              setTimeout(() => {
                this.showSection('auth-section');
              }, 100);
              
            } else {
              // Temporary rejection - can retry
              const canRetryIn = rejection.canRetryAfter ? Math.ceil((rejection.canRetryAfter - Date.now()) / 1000) : 10;
              
              utils.showError('room-error', 
                `‚è∏Ô∏è Your join request was not accepted.\n\n` +
                `You can try joining again in ${canRetryIn} seconds.`
              );
              
              // Clear state but allow retry
              gameState.roomCode = null;
              document.getElementById('roomCode').value = roomCode; // Keep code for retry
              
              // Return to auth section
              setTimeout(() => {
                this.showSection('auth-section');
              }, 100);
            }
          }
        });
        
        // Store listeners for cleanup
        gameState.joinResponseListener = acceptanceRef;
        gameState.rejectionListener = rejectionRef;
        
        // Set timeout for join request (2 minutes)
        gameState.joinRequestTimeout = setTimeout(() => {
          // Check if still waiting
          const statusDiv = document.getElementById('acceptance-status');
          if (statusDiv && !statusDiv.classList.contains('hidden')) {
            acceptanceRef.off('value', acceptanceListener);
            rejectionRef.off('value', rejectionListener);
            
            utils.showNotification('‚è∞ Join request timed out. Please try again.');
            
            // Clean up
            window.db.ref(`rooms/${roomCode}/joinRequests/${playerName}`).remove();
            gameState.playerName = null;
            gameState.roomCode = null;
            
            setTimeout(() => {
              this.showSection('auth-section');
            }, 1500);
          }
        }, 120000); // 2 minutes
      }
    };

    // Share Results Function (Global scope)
    async function shareResults(method) {
      const feedbackEl = document.getElementById('share-feedback');
      
      try {
        switch(method) {
          case 'image':
            feedbackEl.textContent = 'üé® Generating image...';
            feedbackEl.classList.remove('hidden');
            
            const imageDataUrl = shareManager.generateShareImage();
            const shared = await shareManager.shareImage(imageDataUrl);
            
            if (shared) {
              feedbackEl.textContent = '‚úÖ Image shared successfully!';
              utils.announceToScreenReader('Image shared successfully');
            } else {
              // Fallback to download if sharing not supported
              await shareManager.downloadImage(imageDataUrl);
              feedbackEl.textContent = 'üíæ Image downloaded! (Sharing not supported on this device)';
              utils.announceToScreenReader('Image downloaded');
            }
            
            setTimeout(() => feedbackEl.classList.add('hidden'), 3000);
            break;
            
          case 'download':
            feedbackEl.textContent = 'üíæ Generating image...';
            feedbackEl.classList.remove('hidden');
            
            const downloadDataUrl = shareManager.generateShareImage();
            await shareManager.downloadImage(downloadDataUrl);
            
            feedbackEl.textContent = '‚úÖ Image downloaded successfully!';
            utils.announceToScreenReader('Image downloaded successfully');
            setTimeout(() => feedbackEl.classList.add('hidden'), 3000);
            break;
            
          case 'copy':
            let shareText = 'ü™® DALORF Challenge Results üêü\n\n';
            
            if (gameState.myScore !== null) {
              shareText += `${gameState.playerName}: ${gameState.myScore}% - ${gameState.myTag}\n`;
            }
            
            if (gameState.otherScore !== null) {
              shareText += `${gameState.otherPlayerName}: ${gameState.otherScore}% - ${gameState.otherTag}\n`;
            }
            
            shareText += '\nTest how well YOU know your friends at DALORF! üíñ';
            
            await navigator.clipboard.writeText(shareText);
            feedbackEl.textContent = '‚úÖ Results copied to clipboard!';
            feedbackEl.classList.remove('hidden');
            utils.announceToScreenReader('Results copied to clipboard');
            setTimeout(() => feedbackEl.classList.add('hidden'), 3000);
            break;
        }
      } catch (error) {
        console.error('Error sharing:', error);
        feedbackEl.textContent = '‚ùå Failed to share. Please try again.';
        feedbackEl.className = 'error-message';
        feedbackEl.classList.remove('hidden');
        setTimeout(() => {
          feedbackEl.classList.add('hidden');
          feedbackEl.className = 'success-message';
        }, 3000);
      }
    }

    // ========================================
// PROFILE & STATS UI FUNCTIONS
// ========================================

async function showProfile() {
  if (!userState.userId) {
    authManager.showAuthModal('login');
    return;
  }
  
  modalManager.show('profile-modal');
  await loadProfileContent();
}

async function loadProfileContent() {
  const container = document.getElementById('profile-content');
  
  if (!userState.userId) {
    container.innerHTML = '<div class="empty-state">Please sign in to view your profile.</div>';
    return;
  }
  
  // Show loading
  container.innerHTML = '<div class="loading-indicator">Loading profile...</div>';
  
  try {
    // Load fresh stats
    await authManager.loadUserStats();
    const stats = userState.stats || {};
    
    const isAnonymous = userState.isAnonymous;
    
    let content = '';
    
    // Check if user is anonymous first
    if (isAnonymous) {
      // Show upgrade-focused layout for anonymous users
      content = `
        <div class="upgrade-prompt" style="margin: 0;">
          <h3>üëª Playing as Guest</h3>
          <p>Create a free account to save your stats and unlock all features!</p>
          <button onclick="authManager.upgradeAccount()" style="background: white; color: var(--color-accent); font-weight: 700; width: 100%; margin-bottom: 8px;">
            üíé Upgrade to Full Account
          </button>
          <button onclick="authManager.signOut(); modalManager.hide('profile-modal');" style="background: #666; width: 100%;">
            üö™ Sign Out & Start Over
          </button>
        </div>
        
        <div style="margin-top: 24px; padding: 20px; background: var(--bg-card); border-radius: var(--border-radius); border: 2px dashed var(--color-accent);">
          <h4 style="margin-bottom: 12px;">‚ö†Ô∏è Guest Account Limitations:</h4>
          <ul style="text-align: left; margin: 0; padding-left: 20px; line-height: 1.8;">
            <li>Stats are temporary and may be lost</li>
            <li>No leaderboard ranking</li>
            <li>Can't track game history</li>
            <li>Limited partnership features</li>
          </ul>
        </div>
        
        ${stats.totalGames > 0 ? `
          <div style="margin-top: 24px;">
            <h4 style="text-align: center; margin-bottom: 16px;">Current Session Stats</h4>
            <div class="stats-grid">
              <div class="stat-card">
                <div class="stat-value">${stats.totalGames || 0}</div>
                <div class="stat-label">Games</div>
              </div>
              <div class="stat-card">
                <div class="stat-value">${stats.averageScore || 0}%</div>
                <div class="stat-label">Avg Score</div>
              </div>
              <div class="stat-card">
                <div class="stat-value">${stats.bestScore || 0}%</div>
                <div class="stat-label">Best Score</div>
              </div>
              <div class="stat-card">
                <div class="stat-value">${stats.currentStreak || 0}üî•</div>
                <div class="stat-label">Streak</div>
              </div>
            </div>
            <p style="text-align: center; margin-top: 16px; font-weight: 600; color: var(--color-accent);">
              ‚ö° Upgrade now to save these stats forever!
            </p>
          </div>
        ` : ''}
      `;
    } else {
      // Regular profile for full accounts
      content = `
        <div class="profile-card">
          <div class="profile-avatar" id="current-avatar">${userState.photoURL || 'üòÄ'}</div>
          <h3 style="margin: 8px 0 4px 0;">${userState.displayName || userState.username || 'Player'}</h3>
          <p style="color: var(--text-secondary); font-size: 0.9rem;">@${userState.username || 'username'}</p>
          
          <button onclick="showAvatarPicker()" style="margin-top: 12px; font-size: 0.9rem;">
            ‚úèÔ∏è Change Avatar
          </button>
        </div>
        
        <div class="profile-info">
          <div class="profile-info-item">
            <span class="profile-info-label">Display Name</span>
            <span class="profile-info-value" id="display-name-value">${userState.displayName || 'Not set'}</span>
          </div>
          <button onclick="showDisplayNameEditor()" style="width: 100%; margin-top: 8px; font-size: 0.9rem;">
            ‚úèÔ∏è Edit Display Name
          </button>
          
          ${userState.currentUser && userState.currentUser.email ? `
            <div class="profile-info-item">
              <span class="profile-info-label">Email</span>
              <span class="profile-info-value">${userState.currentUser.email}</span>
            </div>
          ` : ''}
          
          <div class="profile-info-item">
            <span class="profile-info-label">Member Since</span>
            <span class="profile-info-value">${formatDate(userState.stats?.lastPlayed || Date.now())}</span>
          </div>
        </div>
        
        <div style="margin-top: 24px;">
          <h3 style="text-align: center; margin-bottom: 16px;">Quick Stats</h3>
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-value">${stats.totalGames || 0}</div>
              <div class="stat-label">Games</div>
            </div>
            <div class="stat-card">
              <div class="stat-value">${stats.averageScore || 0}%</div>
              <div class="stat-label">Avg Score</div>
            </div>
            <div class="stat-card">
              <div class="stat-value">${stats.bestScore || 0}%</div>
              <div class="stat-label">Best Score</div>
            </div>
            <div class="stat-card">
              <div class="stat-value">${stats.currentStreak || 0}üî•</div>
              <div class="stat-label">Streak</div>
            </div>
          </div>
          
          <button onclick="showStats()" style="width: 100%; margin-top: 16px;">
            üìä View Full Stats & Leaderboards
          </button>
        </div>
      `;
    }
    
    container.innerHTML = content;
    
  } catch (error) {
    console.error('Error loading profile:', error);
    container.innerHTML = '<div class="error-message">Failed to load profile. Please try again.</div>';
  }
}

async function showAvatarPicker() {
  const container = document.getElementById('profile-content');
  
  const avatars = [
    'üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÜ', 'üòÖ', 'ü§£', 'üòÇ', 'üôÇ', 'üôÉ', 
    'üòâ', 'üòä', 'üòá', 'ü•∞', 'üòç', 'ü§©', 'üòò', 'üòó', 'üòö', 'üòô',
    'üòã', 'üòõ', 'üòú', 'ü§™', 'üòù', 'ü§ë', 'ü§ó', 'ü§≠', 'ü§´', 'ü§î',
    'ü§ê', 'ü§®', 'üòê', 'üòë', 'üò∂', 'üòè', 'üòí', 'üôÑ', 'üò¨', 'ü§•',
    'üòå', 'üòî', 'üò™', 'ü§§', 'üò¥', 'üò∑', 'ü§í', 'ü§ï', 'ü§¢', 'ü§Æ',
    'ü§ß', 'ü•µ', 'ü•∂', 'ü•¥', 'üòµ', 'ü§Ø', 'ü§†', 'ü•≥', 'üòé', 'ü§ì',
    'üßê', 'üòï', 'üòü', 'üôÅ', '‚òπÔ∏è', 'üòÆ', 'üòØ', 'üò≤', 'üò≥', 'ü•∫',
    'üò¶', 'üòß', 'üò®', 'üò∞', 'üò•', 'üò¢', 'üò≠', 'üò±', 'üòñ', 'üò£',
    'üòû', 'üòì', 'üò©', 'üò´', 'ü•±', 'üò§', 'üò°', 'üò†', 'ü§¨', 'üòà',
    'üëø', 'üíÄ', '‚ò†Ô∏è', 'üí©', 'ü§°', 'üëπ', 'üë∫', 'üëª', 'üëΩ', 'üëæ',
    'ü§ñ', 'üò∫', 'üò∏', 'üòπ', 'üòª', 'üòº', 'üòΩ', 'üôÄ', 'üòø', 'üòæ',
    'üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üê®', 'üêØ',
    'ü¶Å', 'üêÆ', 'üê∑', 'üê∏', 'üêµ', 'üêî', 'üêß', 'üê¶', 'üê§', 'ü¶Ü',
    'ü¶Ö', 'ü¶â', 'ü¶á', 'üê∫', 'üêó', 'üê¥', 'ü¶Ñ', 'üêù', 'üêõ', 'ü¶ã',
    'üêå', 'üêû', 'üêú', 'ü¶ü', 'ü¶ó', 'üï∑Ô∏è', 'ü¶Ç', 'üê¢', 'üêç', 'ü¶é',
    'ü¶ñ', 'ü¶ï', 'üêô', 'ü¶ë', 'ü¶ê', 'ü¶û', 'ü¶Ä', 'üê°', 'üê†', 'üêü',
    'üê¨', 'üê≥', 'üêã', 'ü¶à', 'üêä', 'üêÖ', 'üêÜ', 'ü¶ì', 'ü¶ç', 'ü¶ß'
  ];
  
  const currentAvatar = userState.photoURL || 'üòÄ';
  
  let content = `
    <div style="text-align: center; margin-bottom: 16px;">
      <button onclick="loadProfileContent()" style="font-size: 0.9rem;">
        ‚Üê Back to Profile
      </button>
    </div>
    
    <h3 style="text-align: center; margin-bottom: 16px;">Choose Your Avatar</h3>
    
    <div class="profile-avatar" style="margin: 0 auto 24px;">
      <span id="preview-avatar">${currentAvatar}</span>
    </div>
    
    <div class="avatar-picker">
      ${avatars.map(emoji => `
        <div class="avatar-option ${emoji === currentAvatar ? 'selected' : ''}" 
             onclick="selectAvatar('${emoji}')"
             data-avatar="${emoji}">
          ${emoji}
        </div>
      `).join('')}
    </div>
    
    <button onclick="saveAvatar()" style="width: 100%; margin-top: 16px;">
      üíæ Save Avatar
    </button>
  `;
  
  container.innerHTML = content;
}

function selectAvatar(emoji) {
  // Update preview
  document.getElementById('preview-avatar').textContent = emoji;
  
  // Update selection styling
  document.querySelectorAll('.avatar-option').forEach(option => {
    option.classList.remove('selected');
  });
  document.querySelector(`[data-avatar="${emoji}"]`).classList.add('selected');
  
  // Store temporarily
  window.tempSelectedAvatar = emoji;
}

async function saveAvatar() {
  const selectedAvatar = window.tempSelectedAvatar || userState.photoURL;
  
  try {
    await authManager.updateProfile({ photoURL: selectedAvatar });
    utils.showNotification('‚úÖ Avatar updated!');
    await loadProfileContent();
  } catch (error) {
    console.error('Error saving avatar:', error);
    utils.showNotification('‚ùå Failed to save avatar');
  }
}

async function showDisplayNameEditor() {
  const container = document.getElementById('profile-content');
  
  const currentName = userState.displayName || userState.username || '';
  
  let content = `
    <div style="text-align: center; margin-bottom: 16px;">
      <button onclick="loadProfileContent()" style="font-size: 0.9rem;">
        ‚Üê Back to Profile
      </button>
    </div>
    
    <h3 style="text-align: center; margin-bottom: 16px;">Edit Display Name</h3>
    
    <form id="display-name-form" style="max-width: 400px; margin: 0 auto;">
      <div style="margin-bottom: 16px;">
        <label for="new-display-name" style="display: block; margin-bottom: 8px; font-weight: 600;">
          Display Name
        </label>
        <input type="text" 
               id="new-display-name" 
               value="${currentName}"
               placeholder="Enter display name"
               maxlength="50"
               style="width: 100%; max-width: 100%;"
               required>
        <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px;">
          This is how other players will see you
        </p>
      </div>
      
      <div id="display-name-error" class="error-message hidden"></div>
      
      <button type="submit" style="width: 100%;">
        üíæ Save Display Name
      </button>
    </form>
  `;
  
  container.innerHTML = content;
  
  // Attach form handler
  setTimeout(() => {
    document.getElementById('display-name-form').onsubmit = async (e) => {
      e.preventDefault();
      
      const newName = document.getElementById('new-display-name').value.trim();
      const errorEl = document.getElementById('display-name-error');
      
      if (!newName) {
        errorEl.textContent = 'Display name cannot be empty';
        errorEl.classList.remove('hidden');
        return;
      }
      
      if (newName.length < 2) {
        errorEl.textContent = 'Display name must be at least 2 characters';
        errorEl.classList.remove('hidden');
        return;
      }
      
      try {
        await authManager.updateProfile({ displayName: newName });
        
        // Update Firebase Auth profile as well
        if (userState.currentUser && !userState.isAnonymous) {
          await userState.currentUser.updateProfile({ displayName: newName });
        }
        
        utils.showNotification('‚úÖ Display name updated!');
        await loadProfileContent();
      } catch (error) {
        console.error('Error saving display name:', error);
        errorEl.textContent = 'Failed to update display name';
        errorEl.classList.remove('hidden');
      }
    };
  }, 100);
}

async function showStats() {
  if (!userState.userId) {
    authManager.showAuthModal('login');
    return;
  }
  
  modalManager.show('stats-modal');
  await showStatsTab('personal');
}

async function showStatsTab(tab) {
  // Update tab styling
  document.querySelectorAll('.stats-tab').forEach(btn => {
    btn.classList.remove('active');
  });
  document.getElementById(`stats-tab-${tab}`).classList.add('active');
  
  const container = document.getElementById('stats-tab-content');
  container.innerHTML = '<div class="loading-indicator">Loading...</div>';
  
  try {
    switch(tab) {
      case 'personal':
        await loadPersonalStats(container);
        break;
      case 'partners':
        await loadPartnersStats(container);
        break;
      case 'global':
        await loadGlobalLeaderboard(container);
        break;
      case 'history':
        await loadGameHistory(container);
        break;
    }
  } catch (error) {
    console.error('Error loading stats tab:', error);
    container.innerHTML = '<div class="error-message">Failed to load stats. Please try again.</div>';
  }
}

async function loadPersonalStats(container) {
  const stats = await statsManager.getPersonalStats();
  
  if (!stats) {
    container.innerHTML = `
      <div class="empty-state">
        <div class="empty-state-icon">üìä</div>
        <div class="empty-state-text">No stats yet</div>
        <div class="empty-state-subtext">Play some games to see your stats here!</div>
      </div>
    `;
    return;
  }
  
  const myRank = await statsManager.getMyRank();
  
  let content = `
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-value">${stats.totalGames}</div>
        <div class="stat-label">Total Games</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${stats.totalWins}</div>
        <div class="stat-label">Wins (‚â•70%)</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${stats.winRate}%</div>
        <div class="stat-label">Win Rate</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${stats.averageScore}%</div>
        <div class="stat-label">Average Score</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${stats.bestScore}%</div>
        <div class="stat-label">Best Score</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${stats.currentStreak}üî•</div>
        <div class="stat-label">Current Streak</div>
      </div>
      <div class="stat-card">
        <div class="stat-value">${stats.longestStreak}üî•</div>
        <div class="stat-label">Longest Streak</div>
      </div>
      ${myRank ? `
        <div class="stat-card">
          <div class="stat-value">#${myRank}</div>
          <div class="stat-label">Global Rank</div>
        </div>
      ` : ''}
    </div>
    
    ${stats.lastPlayed ? `
      <p style="text-align: center; margin-top: 20px; color: var(--text-secondary); font-size: 0.9rem;">
        Last played: ${formatDate(stats.lastPlayed)}
      </p>
    ` : ''}
  `;
  
  container.innerHTML = content;
}

async function loadPartnersStats(container) {
  const partners = await statsManager.getGamePartners();
  
  if (!partners || partners.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <div class="empty-state-icon">ü§ù</div>
        <div class="empty-state-text">No game partners yet</div>
        <div class="empty-state-subtext">Play games with friends to see your partnerships here!</div>
      </div>
    `;
    return;
  }
  
  let content = '<div>';
  
  partners.forEach(partner => {
    const compatibilityScore = Math.round((partner.myAvgScore + partner.theirAvgScore) / 2);
    const badge = partner.gamesPlayed >= 10 ? 'üèÜ Regular Partner' : 
                  partner.gamesPlayed >= 5 ? '‚≠ê Frequent' : 
                  'üéÆ New Partner';
    
    content += `
      <div class="partner-card" onclick="showPartnershipDetails('${partner.partnerId}', '${partner.name}')">
        <div class="partner-info">
          <div class="partner-name">üë• ${partner.name}</div>
          <div class="partner-stats">
            ${partner.gamesPlayed} games played | 
            You: ${partner.myAvgScore}% | 
            Them: ${partner.theirAvgScore}% | 
            Compatibility: ${compatibilityScore}%
          </div>
          <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px;">
            Last played: ${formatDate(partner.lastPlayed)}
          </div>
        </div>
        <div class="partner-badge">${badge}</div>
      </div>
    `;
  });
  
  content += '</div>';
  container.innerHTML = content;
}

async function showPartnershipDetails(partnerId, partnerName) {
  const container = document.getElementById('stats-tab-content');
  container.innerHTML = '<div class="loading-indicator">Loading partnership details...</div>';
  
  try {
    const partnership = await statsManager.getPartnershipDetails(partnerId);
    
    if (!partnership) {
      container.innerHTML = '<div class="error-message">Partnership data not found.</div>';
      return;
    }
    
    const myId = userState.userId;
    const scores = partnership.scores || [];
    const recentGames = scores.slice(-10).reverse();
    
    const myTotalScore = scores.reduce((sum, s) => sum + (s[myId] || 0), 0);
    const theirTotalScore = scores.reduce((sum, s) => sum + (s[partnerId] || 0), 0);
    const myAvg = Math.round(myTotalScore / scores.length);
    const theirAvg = Math.round(theirTotalScore / scores.length);
    
    let content = `
      <div style="text-align: center; margin-bottom: 20px;">
        <button onclick="showStatsTab('partners')" style="font-size: 0.9rem;">
          ‚Üê Back to Partners
        </button>
      </div>
      
      <h3 style="text-align: center; margin-bottom: 20px;">
        Partnership with ${partnerName}
      </h3>
      
      <div class="stats-grid" style="margin-bottom: 24px;">
        <div class="stat-card">
          <div class="stat-value">${partnership.gamesPlayed}</div>
          <div class="stat-label">Games Together</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${myAvg}%</div>
          <div class="stat-label">Your Average</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${theirAvg}%</div>
          <div class="stat-label">Their Average</div>
        </div>
        <div class="stat-card">
          <div class="stat-value">${Math.round((myAvg + theirAvg) / 2)}%</div>
          <div class="stat-label">Compatibility</div>
        </div>
      </div>
      
      <h4 style="margin-bottom: 12px;">Recent Games</h4>
      <div class="history-timeline">
        ${recentGames.map((game, index) => {
          const myScore = game[myId] || 0;
          const theirScore = game[partnerId] || 0;
          const isWin = myScore >= 70;
          
          return `
            <div class="history-item">
              <div class="history-item-header">
                <span class="history-opponent">Game ${scores.length - index}</span>
                <span class="history-date">${formatDate(game.timestamp)}</span>
              </div>
              <div class="history-scores">
                <div class="history-score ${isWin ? 'win' : 'loss'}">
                  You: ${myScore}% ${isWin ? '‚úÖ' : ''}
                </div>
                <div class="history-score">
                  Them: ${theirScore}%
                </div>
              </div>
            </div>
          `;
        }).join('')}
      </div>
    `;
    
    container.innerHTML = content;
    
  } catch (error) {
    console.error('Error loading partnership details:', error);
    container.innerHTML = '<div class="error-message">Failed to load partnership details.</div>';
  }
}

async function loadGlobalLeaderboard(container) {
  const leaderboard = await statsManager.getGlobalLeaderboard(50);
  
  if (!leaderboard || leaderboard.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <div class="empty-state-icon">üåç</div>
        <div class="empty-state-text">No leaderboard data yet</div>
        <div class="empty-state-subtext">Be the first to play and make it to the top!</div>
      </div>
    `;
    return;
  }
  
  let content = `
    <div style="overflow-x: auto;">
      <table class="leaderboard-table">
        <thead>
          <tr>
            <th>Rank</th>
            <th>Player</th>
            <th>Avg Score</th>
            <th>Best Score</th>
            <th>Games</th>
          </tr>
        </thead>
        <tbody>
  `;
  
  leaderboard.forEach((player, index) => {
    const rank = index + 1;
    const isMe = player.userId === userState.userId;
    const rankClass = rank <= 3 ? `rank-${rank}` : '';
    
    content += `
      <tr class="${isMe ? 'leaderboard-me' : ''}">
        <td class="leaderboard-rank ${rankClass} ${rank <= 3 ? 'top-3' : ''}">${rank}</td>
        <td>
          <span class="leaderboard-avatar">${player.photoURL || 'üòÄ'}</span>
          ${player.displayName || player.username || 'Player'}
          ${isMe ? '<strong>(You)</strong>' : ''}
        </td>
        <td><strong>${player.avgScore}%</strong></td>
        <td>${player.bestScore}%</td>
        <td>${player.totalGames}</td>
      </tr>
    `;
  });
  
  content += `
        </tbody>
      </table>
    </div>
  `;
  
  container.innerHTML = content;
}

async function loadGameHistory(container) {
  const history = await statsManager.getGameHistory(50);
  
  if (!history || history.length === 0) {
    container.innerHTML = `
      <div class="empty-state">
        <div class="empty-state-icon">üìú</div>
        <div class="empty-state-text">No game history yet</div>
        <div class="empty-state-subtext">Your past games will appear here!</div>
      </div>
    `;
    return;
  }
  
  let content = `
    <div class="history-timeline">
  `;
  
  history.forEach(game => {
    const isWin = game.myScore >= 70;
    
    content += `
      <div class="history-item">
        <div class="history-item-header">
          <span class="history-opponent">vs ${game.opponentName}</span>
          <span class="history-date">${formatDate(game.timestamp)}</span>
        </div>
        <div class="history-scores">
          <div class="history-score ${isWin ? 'win' : 'loss'}">
            You: ${game.myScore}% ${isWin ? '‚úÖ' : '‚ùå'}
          </div>
          ${game.theirScore !== null ? `
            <div class="history-score">
              Them: ${game.theirScore}%
            </div>
          ` : ''}
        </div>
        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px;">
          Room: ${game.roomCode} | Round: ${game.roundNumber || 1}
        </div>
      </div>
    `;
  });
  
  content += '</div>';
  container.innerHTML = content;
}

function formatDate(timestamp) {
  if (!timestamp) return 'Unknown';
  
  const date = new Date(timestamp);
  const now = new Date();
  const diffMs = now - date;
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);
  
  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins} minute${diffMins > 1 ? 's' : ''} ago`;
  if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
  if (diffDays < 7) return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;
  
  return date.toLocaleDateString('en-US', { 
    month: 'short', 
    day: 'numeric', 
    year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined 
  });
}

// ========================================
// END OF PROFILE & STATS UI FUNCTIONS
// ========================================
    function showAboutName() {
      modalManager.show('about-name-modal');
    }

    function closeAboutName() {
      modalManager.hide('about-name-modal');
    }

    function showInstructions() {
      modalManager.show('instructions-modal');
    }

    function closeInstructions() {
      modalManager.hide('instructions-modal');
    }

    // Game Functions (Global scope)
    function createRoom() {
      gameManager.createRoom();
    }

    function joinRoom() {
      gameManager.joinRoom();
    }

    function startGameSetup() {
      gameManager.startGameSetup();
    }

    function generateAutomatedQuestions() {
      gameManager.generateAutomatedQuestions();
    }

    function addQuestion(qData) {
      gameManager.addQuestion(qData);
    }

    function submitQuestions() {
      gameManager.submitQuestions();
    }

    function pauseAndEdit() {
      gameManager.pauseAndEdit();
    }

    function submitAnswers() {
      gameManager.submitAnswers();
    }

    // Event Listeners
    document.addEventListener('DOMContentLoaded', function() {
      themeManager.init();

      // Initialize auth and check for existing session
      authManager.init().then(() => {
        // Check if user wants to reconnect to game
        if (userState.userId) {
          sessionManager.attemptReconnect();
        }

        // Enter key support for faster gameplay
  document.addEventListener('keypress', function(e) {
    if (e.key !== 'Enter' || e.shiftKey) return;
    
    const activeElement = document.activeElement;
    const activeSection = document.querySelector('.section:not(.hidden)');
    
    // Don't submit if typing in a textarea or the enter is for autocomplete
    if (activeElement.tagName === 'TEXTAREA') return;
    
    if (activeSection) {
      // Join room when Enter pressed in room code field
      if (activeSection.id === 'auth-section' && activeElement.id === 'roomCode') {
        const roomCode = document.getElementById('roomCode').value.trim();
        if (roomCode) {
          joinRoom();
        }
      }
    }
  });
  
  const perfEnd = performance.now();
      });
      
      const themeSwitchBtn = document.getElementById('theme-switch');
      if (themeSwitchBtn) {
        themeSwitchBtn.addEventListener('click', () => themeManager.toggle());
      }
      
      const aboutBtn = document.getElementById('about-name');
      if (aboutBtn) {
        aboutBtn.addEventListener('click', showAboutName);
      }
      
      const profileBtn = document.getElementById('profile-btn');
    if (profileBtn) {
      profileBtn.addEventListener('click', showProfile);
    }

      document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') {
          closeInstructions();
          closeAboutName();
        }
      });
      
      window.addEventListener('click', function(event) {
        const instructionsModal = document.getElementById('instructions-modal');
        const aboutModal = document.getElementById('about-name-modal');
        
        if (event.target === instructionsModal) {
          closeInstructions();
        }
        if (event.target === aboutModal) {
          closeAboutName();
        }
      });
      
      const roomCodeInput = document.getElementById('roomCode');
      if (roomCodeInput) {
        roomCodeInput.addEventListener('input', function() {
          // Remove spaces and convert to uppercase
          this.value = this.value.replace(/\s+/g, '').toUpperCase();
          
          // Remove invalid characters (only allow letters and numbers)
          this.value = this.value.replace(/[^A-Z0-9]/g, '');
        });
        
        // Also clean on paste
        roomCodeInput.addEventListener('paste', function(e) {
          e.preventDefault();
          const pastedText = (e.clipboardData || window.clipboardData).getData('text');
          const cleaned = pastedText.replace(/\s+/g, '').toUpperCase().replace(/[^A-Z0-9]/g, '');
          this.value = cleaned;
          this.dispatchEvent(new Event('input')); // Trigger input validation
        });
      }
      
      const perfEnd = performance.now();
      console.log(`DALORF initialization completed in ${(perfEnd - perfStart).toFixed(2)}ms`);
    });

    window.addEventListener('beforeunload', function() {
      gameManager.cleanup();
    });

    window.addEventListener('error', function(event) {
      console.error('JavaScript error:', event.error);
      utils.showNotification('An error occurred. Please refresh the page if issues persist.', 6000);
    });

    window.addEventListener('unhandledrejection', function(event) {
      console.error('Unhandled promise rejection:', event.reason);
      event.preventDefault();
    });

    // Expose necessary functions to global scope
    window.gameManager = gameManager;
    window.shareManager = shareManager;
    window.showAboutName = showAboutName;
    window.closeAboutName = closeAboutName;
    window.showInstructions = showInstructions;
    window.closeInstructions = closeInstructions;
    window.createRoom = createRoom;
    window.joinRoom = joinRoom;
    window.startGameSetup = startGameSetup;
    window.generateAutomatedQuestions = generateAutomatedQuestions;
    window.addQuestion = addQuestion;
    window.submitQuestions = submitQuestions;
    window.pauseAndEdit = pauseAndEdit;
    window.submitAnswers = submitAnswers;
    window.shareResults = shareResults;
    window.showProfile = showProfile;
    window.showStats = showStats;
    window.showStatsTab = showStatsTab;
    window.selectAvatar = selectAvatar;
    window.saveAvatar = saveAvatar;
    window.showDisplayNameEditor = showDisplayNameEditor;
    window.showAvatarPicker = showAvatarPicker;
    window.showPartnershipDetails = showPartnershipDetails;
    window.formatDate = formatDate;

    async function startNewRound() {
      if (!gameState.opponentUserId) {
        utils.showNotification('Cannot start new round - opponent info missing');
        return;
      }
      
      // Clear previous game data
      gameState.myScore = null;
      gameState.myTag = null;
      gameState.otherScore = null;
      gameState.otherTag = null;
      gameState.reviewCompleted = false;
      gameState.isReviewPaused = false;
      gameState.reviewEndTime = null;
      
      if (gameState.reviewInterval) {
        clearInterval(gameState.reviewInterval);
        gameState.reviewInterval = null;
      }
      
      gameState.currentRound++;
      
      try {
        // Check if we're the room creator
        const settingsSnapshot = await window.db.ref(`rooms/${gameState.roomCode}/settings`).once('value');
        const settings = settingsSnapshot.val();
        const isCreator = settings && settings.creator === gameState.playerName;
        
        // Clear old room data for fresh round
        if (window.db && gameState.roomCode) {
          await window.db.ref(`rooms/${gameState.roomCode}/questions`).remove();
          await window.db.ref(`rooms/${gameState.roomCode}/answers`).remove();
          await window.db.ref(`rooms/${gameState.roomCode}/gameState`).remove();
          
          // If we're the creator, also clear the question count requirement
          if (isCreator) {
            await window.db.ref(`rooms/${gameState.roomCode}/settings/requiredQuestionCount`).remove();
            gameState.requiredQuestionCount = 5; // Reset to default
          }
        }
        
        if (userState.sessionId) {
          await statsManager.incrementSessionRound(userState.sessionId);
        }
        
        // Reset game state
        await dbManager.updateGameState(GAME_STATES.SETUP);
        
        // Show appropriate screen based on role
        if (isCreator) {
          gameManager.showSection('question-setup-section');
          utils.showNotification(`üîÑ Round ${gameState.currentRound} - Select question count!`);
        } else {
          gameManager.showSection('waiting-section');
          document.getElementById('waiting-section').innerHTML = 
            '<div class="loading-indicator">‚è≥ Waiting for room creator to set up the next round...</div>';
          gameManager.listenForRoomUpdates();
          utils.showNotification(`üîÑ Round ${gameState.currentRound} - Waiting for setup...`);
        }
        
      } catch (error) {
        console.error('Error starting new round:', error);
        utils.showNotification('Failed to start new round. Please refresh.');
      }
    }

    window.showAboutName = showAboutName;
    window.authManager = authManager;
    window.statsManager = statsManager;
    window.modalManager = modalManager;
    window.startNewRound = startNewRound;
    window.showAboutName = showAboutName;
    window.authManager = authManager;
    window.statsManager = statsManager;
    window.modalManager = modalManager;
    window.startNewRound = startNewRound;

    async function acceptPlayer(playerName) {
      if (!window.db || !gameState.roomCode) return;
      
      try {
        // Disable all accept/reject buttons
        const buttons = document.querySelectorAll('#join-requests-container button');
        buttons.forEach(btn => btn.disabled = true);
        
        utils.showNotification(`‚úÖ Accepting ${playerName}...`);
        
        // 1. Update room settings to mark as game starting
        await window.db.ref(`rooms/${gameState.roomCode}/settings`).update({
          roomStatus: 'game_started',
          acceptedPlayer: playerName,
          acceptedAt: Date.now()
        });
        
        // 2. Remove the join request
        await window.db.ref(`rooms/${gameState.roomCode}/joinRequests/${playerName}`).remove();
        
        // 3. Notify accepted player by creating acceptance node
        await window.db.ref(`rooms/${gameState.roomCode}/acceptances/${playerName}`).set({
          accepted: true,
          timestamp: Date.now()
        });
        
        // 4. Clear room timeout
        if (gameState.roomTimeout) {
          clearTimeout(gameState.roomTimeout);
        }
        
        // 5. Set the other player name
        gameState.otherPlayerName = playerName;
        
        // 6. Try to get opponent's userId for stats tracking
        if (!gameState.opponentUserId) {
          const userId = await statsManager.getUserIdByName(playerName);
          if (userId) {
            gameState.opponentUserId = userId;
            gameState.opponentName = playerName;
          }
        }
        
        // 7. Add to session if exists
        const settingsSnapshot = await window.db.ref(`rooms/${gameState.roomCode}/settings`).once('value');
        const settings = settingsSnapshot.val();
        if (settings.sessionId && userState.userId && !userState.isAnonymous) {
          try {
            await statsManager.addPlayerToSession(settings.sessionId, userState.userId);
          } catch (error) {
            console.warn('Failed to add to session:', error);
          }
        }
        
        // 8. Update room info
        dbManager.updateRoomInfo();
        
        // 9. Save session
        sessionManager.saveSession();
        
        utils.showNotification(`‚úÖ ${playerName} accepted! Setting up game...`);
        
        // 10. Move to question setup
        setTimeout(() => {
          gameManager.showSection('question-setup-section');
        }, 1000);
        
      } catch (error) {
        console.error('Error accepting player:', error);
        utils.showNotification('‚ùå Failed to accept player. Please try again.');
        // Re-enable buttons
        const buttons = document.querySelectorAll('#join-requests-container button');
        buttons.forEach(btn => btn.disabled = false);
      }
    }

    async function rejectPlayer(playerName) {
      if (!window.db || !gameState.roomCode) return;
      
      const confirmed = confirm(`Reject ${playerName}?\n\nThey will be able to try joining once more.`);
      if (!confirmed) return;
      
      try {
        // Disable buttons
        const buttons = document.querySelectorAll('#join-requests-container button');
        buttons.forEach(btn => btn.disabled = true);
        
        utils.showNotification(`‚ùå Rejecting ${playerName}...`);
        
        // 1. Check if already rejected once
        const requestSnapshot = await window.db.ref(`rooms/${gameState.roomCode}/joinRequests/${playerName}`).once('value');
        const requestData = requestSnapshot.val();
        
        if (requestData && requestData.rejectedOnce) {
          // Second rejection - permanent
          await window.db.ref(`rooms/${gameState.roomCode}/rejections/${playerName}`).set({
            rejected: true,
            permanent: true,
            timestamp: Date.now()
          });
          
          utils.showNotification(`üö´ ${playerName} permanently rejected from this room`);
        } else {
          // First rejection - can try again
          await window.db.ref(`rooms/${gameState.roomCode}/rejections/${playerName}`).set({
            rejected: true,
            permanent: false,
            timestamp: Date.now(),
            canRetryAfter: Date.now() + 10000 // 10 seconds cooldown
          });
          
          // Mark as rejected once
          await window.db.ref(`rooms/${gameState.roomCode}/joinRequests/${playerName}`).update({
            rejectedOnce: true
          });
          
          utils.showNotification(`‚è∏Ô∏è ${playerName} rejected - they can retry after 10 seconds`);
        }
        
        // 2. Remove the join request UI
        gameManager.removeJoinRequestUI(playerName);
        
        // 3. Remove from requests after short delay
        setTimeout(async () => {
          await window.db.ref(`rooms/${gameState.roomCode}/joinRequests/${playerName}`).remove();
        }, 1000);
        
      } catch (error) {
        console.error('Error rejecting player:', error);
        utils.showNotification('‚ùå Failed to reject player. Please try again.');
        // Re-enable buttons
        const buttons = document.querySelectorAll('#join-requests-container button');
        buttons.forEach(btn => btn.disabled = false);
      }
    }

    async function cancelRoom() {
      const confirmed = confirm('Cancel this room?\n\nThe room will be deleted and you\'ll return to the start.');
      if (!confirmed) return;
      
      try {
        // Clear timeout
        if (gameState.roomTimeout) {
          clearTimeout(gameState.roomTimeout);
        }
        
        // Clean up listeners
        if (gameState.joinRequestsListener) {
          gameState.joinRequestsListener.off();
        }
        
        // Delete room
        if (window.db && gameState.roomCode) {
          await window.db.ref(`rooms/${gameState.roomCode}`).remove();
        }
        
        // Clear session
        sessionManager.clearSession();
        
        utils.showNotification('‚ùå Room cancelled');
        
        // Reload page
        setTimeout(() => location.reload(), 1000);
        
      } catch (error) {
        console.error('Error cancelling room:', error);
        utils.showNotification('Failed to cancel room properly. Reloading...');
        setTimeout(() => location.reload(), 1500);
      }
    }

    async function cancelJoinRequest() {
      if (!window.db || !gameState.roomCode || !gameState.playerName) {
        location.reload();
        return;
      }
      
      try {
        // Remove join request
        await window.db.ref(`rooms/${gameState.roomCode}/joinRequests/${gameState.playerName}`).remove();
        
        // Stop listening
        if (gameState.joinResponseListener) {
          gameState.joinResponseListener.off();
        }
        
        // Clear game state
        gameState.playerName = null;
        gameState.roomCode = null;
        
        // Clear session
        sessionManager.clearSession();
        
        utils.showNotification('‚ùå Join request cancelled');
        
        // Return to auth section
        gameManager.showSection('auth-section');
        
      } catch (error) {
        console.error('Error cancelling join request:', error);
        location.reload();
      }
    }

    window.acceptPlayer = acceptPlayer;
    window.rejectPlayer = rejectPlayer;
    window.cancelRoom = cancelRoom;
    window.cancelJoinRequest = cancelJoinRequest;

    function copyRoomCode() {
  navigator.clipboard.writeText(gameState.roomCode).then(() => {
    utils.showNotification('‚úÖ Room code copied to clipboard!');
  }).catch(() => {
    // Fallback for older browsers
    const textArea = document.createElement('textarea');
    textArea.value = gameState.roomCode;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    utils.showNotification('‚úÖ Room code copied!');
  });
}

window.copyRoomCode = copyRoomCode;

  </script>
</body>
</html>
